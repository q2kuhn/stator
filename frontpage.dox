/*! 
  \mainpage Stator Documentation
  
  \section frontpage_about About the stator library

  The stator library is a compile-time heap-allocated symbolic math
  library. This means it is really, really, fast (zero overhead, or
  even less thanks to cancellation!) but it lacks the generality of a
  full CAS (Computer Algebra Systems).

  A fancy motivational example.

  \dontinclude symbolic_example.cpp
  \skip //Fancy
  \until }

  See the \ref symbolic_guide "guide to the symbolic library" for more.

  \section frontpage_usage Using the stator library

  stator is a header-only C++11 library. In many places it builds upon
  the Eigen 3 library (http://eigen.tuxfamily.org/), so to use it you
  must have both added to your compiler include path. For example, on linux
  
  \code{.unparsed}
  g++ -I /path/to/stator/folder -I /path/to/Eigen/folder
  \endcode

  The library uses a range of advanced techniques to provide
  interesting mathematical capability. For more information have a
  look at the documentation for each namespace:

  - stator::sym: Symbolic math library (\ref symbolic_guide "guide here")
  
*/

namespace stator {
  namespace sym {
    /*!
      \page symbolic_guide Guide to stator::sym

      \brief This is a short introduction to the compile-time symbolic algebra library.
      
      This guide demonstrates the stator::symbolic library through
      example usage. The example is available in the source file
      symbolic_example.cpp in the examples folder.

      First, we include the stator::sym library header file and bring
      the sym namespace into scope for convenience:
    
      \dontinclude symbolic_example.cpp
      \skipline #include <stator
      \until using
      
      \section sym_guide_const_var Constants and Variables

      The power of this library is in the ability of the compiler to
      simplify and analyse mathematical expressions. To enable this,
      mathematical expressions must be encoded as a type. One of the
      most important type encodings is the rational constants type,
      \ref sym::C.
   
      \until //Output:
    
      You may have a large number of different variables too, and these
      are identified by a number in their type:

      \until var2
    
      Of course, it is "nicer" to use the fact that single characters
      are also number types in C++ and use these instead to identify
      your variables:

      \until Var<'y'>

      But please note, as 'x' is the decimal number 120 in ASCII the
      definitions Variable<'x'> and \ref sym::Var "Variable"<120> are
      equivalent.

      The power of the library primarily arises from its ability to
      cancel zero terms. Any term multiplied by zero (\ref sym::Null "C<0>",
      AKA \ref sym::Null) is cancelled to zero:

      \until assert

      Equally, any term multiplied by one (\ref sym::Unity "C<1>", which has a
      convenient typedef of \ref sym::Unity), is left unchanged:

      \until assert
    
      The simplification rules are not that advanced by default. They
      almost always preserve the input form of the equation:

      \until output
    
      Here you'll see that expressions can be written out to std::cout,
      and that the order of operations is preserved from the original
      input. Here we're using floating-point and integer constants such
      as 1.5 and 2. The types of these constants are preserved and they
      remain integers or floats. They are not converted to compile time
      constants due to limitations of the C++ language. Unfortunately,
      this limits the amount of simplification that can be done at
      compile-time so \ref sym::C values should be used wherever possible.

      \section sym_guide_poly Polynomial types
      However, there is a \ref sym::simplify function which allows
      rearrangement and run-time calculations (such as combination of
      compile-time and run-time constants) to simplify expressions. For
      example:
    
      \until output

      In this particular case, the expression has now become a
      Polynomial type, as denoted by the enclosing P(..) on the
      output. The Polynomial class represents a polynomial in one
      variable as an array of integer or floating-point
      coefficients. This form is required if we need to perform analysis
      such as root finding:
    
      \until output

      Here there are three real roots, and they are returned in a \ref
      stator::orphan::StackVector "StackVector", which behaves like a
      std::vector with a fixed maximum size. The library is capable of
      solving for the real roots of arbitrary polynomials, but relies on
      numerical schemes for polynomials of any order greater than three.
    
      We have seen how to analyse polynomials, but not how to evaluate
      them. We evaluate expressions by substituting the variable for a
      float or integer value, or even another symbolic expression:
    
      \until output
      \until output

      \section sym_guide_adv_functions More complex functions

      These are the basics of the library, but there is growing support
      for complex functions. For example, basic trigonometry functions
      like \ref sin and \ref cos functions are supported. There are also
      some operators which allow you to manipulate a function. For
      example, you may take the partial derivative of a function
      by a variable:

      \until output

      We can also take Taylor expansions of complex expressions to
      extract an approximate Polynomial form:

      \until output

      \section vec_sym_guide Vector expressions
    
      The symbolic library also supports Eigen vector/matrix
      expressions.
      
      \until output
      
      You have to be careful though. Eigen preserves the row/column
      nature of the vectors so operations like multiplication may
      cause compile errors
      
      \until fvec * fvec

      However, taking the square of a vector polynomial expression is
      well defined as the dot product with itself: 
      
      \until output
    */
  }
}
/*! \brief The stator library namespace.

  Although the \ref stator namespace is used for shared functionality
  (e.g., \ref stator::Exception), most of the code is implemented
  under the namespaces \ref stator::sym, \ref stator::geometry,
  and \ref stator::orphan.  
*/ namespace stator {
   
     /*! \namespace stator::geometry 

       \brief Geometric types and algorithms for calculating properties
       (e.g., intersection, volume).
     */
     namespace geometry {
       /*! \brief Compute a Hausdorf measure of the interior of an object.

         The measure returned depends on the dimensionality of the
         object, a circle will return its area but a sphere will return
         its volume
       */
       template<typename Obj> auto volume(const Obj&);

       /*! \brief Compute a Hausdorf measure of the boundary/boundaries
         of an object.
      
         The measure returned depends on the dimensionality object. For
         example, a Sphere will return its surface area whereas a circle
         will return its perimeter.
       */
       template<typename Obj> auto area(const Obj&);

       /*! \brief Determine if two objects are intersecting.
        */
       bool intersects(const Object1&, const Object2&);
     } // namespace geometry
  
  
     /*! \namespace stator::orphan
       \brief General functionality without a particular grouping.
     */
     namespace orphan {
     } // namespace orphan

  
     /*! \namespace stator::sym
       \brief The stator symbolic math library.
    
       This namespace encapsulates the symbolic math functionality of
       stator. This library allows you to perform compile-time operations
       on mathematical expressions, as well as perform run-time
       calculations, such as root finding on polynomials.    
     */
     namespace sym {
  
       /*! \brief Performs a symbolic derivative on the expression.
        */
       template<typename Expression>
       auto derivative(const Expression&);
  
     } // namespace sym

} // namespace stator
