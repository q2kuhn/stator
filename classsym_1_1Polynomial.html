<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>stator: sym::Polynomial&lt; Order, Coeff_t, PolyVar &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">stator
   </div>
   <div id="projectbrief">A math, geometry, and utility library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesym.html">sym</a></li><li class="navelem"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classsym_1_1Polynomial-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sym::Polynomial&lt; Order, Coeff_t, PolyVar &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Array representation of <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a>.  
 <a href="classsym_1_1Polynomial.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sym::Polynomial&lt; Order, Coeff_t, PolyVar &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsym_1_1Polynomial.png" usemap="#sym::Polynomial_3C_20Order_2C_20Coeff_5Ft_2C_20PolyVar_20_3E_map" alt=""/>
  <map id="sym::Polynomial_3C_20Order_2C_20Coeff_5Ft_2C_20PolyVar_20_3E_map" name="sym::Polynomial&lt; Order, Coeff_t, PolyVar &gt;_map">
<area href="structsym_1_1SymbolicOperator.html" title="A type trait to denote symbolic terms (i.e., one that is not yet immediately evaluable to a &quot;normal&quot; ..." alt="sym::SymbolicOperator" shape="rect" coords="274,0,538,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0178f8426d39faf229a644966db572ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#a0178f8426d39faf229a644966db572ad">Polynomial</a> ()</td></tr>
<tr class="memdesc:a0178f8426d39faf229a644966db572ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a0178f8426d39faf229a644966db572ad">More...</a><br /></td></tr>
<tr class="separator:a0178f8426d39faf229a644966db572ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be259aa9b118a35d6e684da3348b537"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#a6be259aa9b118a35d6e684da3348b537">Polynomial</a> (std::initializer_list&lt; Coeff_t &gt; _list)</td></tr>
<tr class="memdesc:a6be259aa9b118a35d6e684da3348b537"><td class="mdescLeft">&#160;</td><td class="mdescRight">List initializer for simple <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> construction.  <a href="#a6be259aa9b118a35d6e684da3348b537">More...</a><br /></td></tr>
<tr class="separator:a6be259aa9b118a35d6e684da3348b537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e4c013e631aab032ab4791f2d05375"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:af8e4c013e631aab032ab4791f2d05375"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#af8e4c013e631aab032ab4791f2d05375">Polynomial</a> (InputIt first, InputIt last)</td></tr>
<tr class="separator:af8e4c013e631aab032ab4791f2d05375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678dfc42d06abd4e8450d714f0c6147b"><td class="memTemplParams" colspan="2">template&lt;size_t N, class Coeff_t2 , class PolyVar2 &gt; </td></tr>
<tr class="memitem:a678dfc42d06abd4e8450d714f0c6147b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#a678dfc42d06abd4e8450d714f0c6147b">Polynomial</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; <a class="el" href="namespacesym.html#a9001edc8c0de50043e7e2cda991e2519">N</a>, Coeff_t2, PolyVar2 &gt; &amp;poly)</td></tr>
<tr class="memdesc:a678dfc42d06abd4e8450d714f0c6147b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for constructing higher-order <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> types from lower order <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> types.  <a href="#a678dfc42d06abd4e8450d714f0c6147b">More...</a><br /></td></tr>
<tr class="separator:a678dfc42d06abd4e8450d714f0c6147b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e2900178885c27cb1c299f404b126c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#a73e2900178885c27cb1c299f404b126c">operator-</a> () const </td></tr>
<tr class="memdesc:a73e2900178885c27cb1c299f404b126c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary negative operator to change the sign of a <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a>.  <a href="#a73e2900178885c27cb1c299f404b126c">More...</a><br /></td></tr>
<tr class="separator:a73e2900178885c27cb1c299f404b126c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a942b02dde4542b8da603da9abbb64bfc"><td class="memTemplParams" colspan="2">template&lt;class Config  = DefaultSimplifyConfig, class PolyVar , class... VarArgs, size_t Order, class Real , typename  = typename std::enable_if&lt;Config::expand_to_Polynomial &amp;&amp; variable_in&lt;Var&lt;VarArgs...&gt;, PolyVar&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a942b02dde4542b8da603da9abbb64bfc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order+1, Real, PolyVar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#a942b02dde4542b8da603da9abbb64bfc">simplify</a> (<a class="el" href="namespacesym.html#a866e1c4e67928b4dc39ed6d99b2dd164">MultiplyOp</a>&lt; <a class="el" href="structsym_1_1Var.html">Var</a>&lt; VarArgs... &gt;, <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Real, PolyVar &gt; &gt; &amp;f)</td></tr>
<tr class="memdesc:a942b02dde4542b8da603da9abbb64bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait which determines if an operation (multiplication, addition) can be distributed over the coefficients of a polynomial.  <a href="#a942b02dde4542b8da603da9abbb64bfc">More...</a><br /></td></tr>
<tr class="separator:a942b02dde4542b8da603da9abbb64bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Polynomial roots</div></td></tr>
<tr class="memitem:a5bfe1fe4dfe312a968062393a59c6afc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#a5bfe1fe4dfe312a968062393a59c6afc">PolyRootBounder</a> <tr class="memdesc:a5bfe1fe4dfe312a968062393a59c6afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the types of root bounding methods we have for solve_real_roots.  <a href="classsym_1_1Polynomial.html#a5bfe1fe4dfe312a968062393a59c6afc">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a5bfe1fe4dfe312a968062393a59c6afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aecceaf5e103c3ed975c7f650619090"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#a0aecceaf5e103c3ed975c7f650619090">PolyRootBisector</a> <tr class="memdesc:a0aecceaf5e103c3ed975c7f650619090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the types of bisection routines we have for solve_real_roots .  <a href="classsym_1_1Polynomial.html#a0aecceaf5e103c3ed975c7f650619090">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a0aecceaf5e103c3ed975c7f650619090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7e992dadc5d5ea4b1cfca9ddd8e50c"><td class="memTemplParams" colspan="2">template&lt;class Coeff_t , size_t Order, class Coeff_t2 , class PolyVar &gt; </td></tr>
<tr class="memitem:a7f7e992dadc5d5ea4b1cfca9ddd8e50c"><td class="memTemplItemLeft" align="right" valign="top">Coeff_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#a7f7e992dadc5d5ea4b1cfca9ddd8e50c">precision</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;f, const Coeff_t2 &amp;x)</td></tr>
<tr class="memdesc:a7f7e992dadc5d5ea4b1cfca9ddd8e50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a maximum error estimate for the evaluation of the polynomial at <img class="formulaInl" alt="$x$" src="form_0.png"/>.  <a href="#a7f7e992dadc5d5ea4b1cfca9ddd8e50c">More...</a><br /></td></tr>
<tr class="separator:a7f7e992dadc5d5ea4b1cfca9ddd8e50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abceed2e1f15d2a0f1a50943806c4b853"><td class="memTemplParams" colspan="2">template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </td></tr>
<tr class="memitem:abceed2e1f15d2a0f1a50943806c4b853"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order-1, Coeff_t, PolyVar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#abceed2e1f15d2a0f1a50943806c4b853">deflate_polynomial</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;a, const double root)</td></tr>
<tr class="memdesc:abceed2e1f15d2a0f1a50943806c4b853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factors out a root of a polynomial and returns a lower-order polynomial with the remaining roots.  <a href="#abceed2e1f15d2a0f1a50943806c4b853">More...</a><br /></td></tr>
<tr class="separator:abceed2e1f15d2a0f1a50943806c4b853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5463d42e10f39ce3d00504eaf2eafb8f"><td class="memTemplParams" colspan="2">template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </td></tr>
<tr class="memitem:a5463d42e10f39ce3d00504eaf2eafb8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order-1, Coeff_t, PolyVar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#a5463d42e10f39ce3d00504eaf2eafb8f">deflate_polynomial</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;a, <a class="el" href="namespacesym.html#a906fb1169f4d948d53f4e868a14fe783">Null</a>)</td></tr>
<tr class="memdesc:a5463d42e10f39ce3d00504eaf2eafb8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialisation of deflation where the root is at zero.  <a href="#a5463d42e10f39ce3d00504eaf2eafb8f">More...</a><br /></td></tr>
<tr class="separator:a5463d42e10f39ce3d00504eaf2eafb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4ec7d0395e3cbff42ed49086ddcac2"><td class="memTemplParams" colspan="2">template&lt;class PolyVar &gt; </td></tr>
<tr class="memitem:aee4ec7d0395e3cbff42ed49086ddcac2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstator_1_1orphan_1_1StackVector.html">StackVector</a>&lt; double, 0 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#aee4ec7d0395e3cbff42ed49086ddcac2">solve_real_roots</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; 0, double, PolyVar &gt; &amp;f)</td></tr>
<tr class="memdesc:aee4ec7d0395e3cbff42ed49086ddcac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation for no roots of a 0th order <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a>.  <a href="#aee4ec7d0395e3cbff42ed49086ddcac2">More...</a><br /></td></tr>
<tr class="separator:aee4ec7d0395e3cbff42ed49086ddcac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787fe2e8facef3b1a5de5bc4e94d4752"><td class="memTemplParams" colspan="2">template&lt;class PolyVar &gt; </td></tr>
<tr class="memitem:a787fe2e8facef3b1a5de5bc4e94d4752"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstator_1_1orphan_1_1StackVector.html">StackVector</a>&lt; double, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#a787fe2e8facef3b1a5de5bc4e94d4752">solve_real_roots</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; 1, double, PolyVar &gt; &amp;f)</td></tr>
<tr class="memdesc:a787fe2e8facef3b1a5de5bc4e94d4752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the single real root (if it exists) of a 1st order <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a>.  <a href="#a787fe2e8facef3b1a5de5bc4e94d4752">More...</a><br /></td></tr>
<tr class="separator:a787fe2e8facef3b1a5de5bc4e94d4752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf5e18eb8d2b66f673774bc0732fdd6"><td class="memTemplParams" colspan="2">template&lt;class PolyVar &gt; </td></tr>
<tr class="memitem:aaaf5e18eb8d2b66f673774bc0732fdd6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstator_1_1orphan_1_1StackVector.html">StackVector</a>&lt; double, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#aaaf5e18eb8d2b66f673774bc0732fdd6">solve_real_roots</a> (<a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; 2, double, PolyVar &gt; f)</td></tr>
<tr class="memdesc:aaaf5e18eb8d2b66f673774bc0732fdd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcualte the real roots of a 2nd order <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> using radicals.  <a href="#aaaf5e18eb8d2b66f673774bc0732fdd6">More...</a><br /></td></tr>
<tr class="separator:aaaf5e18eb8d2b66f673774bc0732fdd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35fb524d245204c99adc811ec16e539a"><td class="memTemplParams" colspan="2">template&lt;class PolyVar &gt; </td></tr>
<tr class="memitem:a35fb524d245204c99adc811ec16e539a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstator_1_1orphan_1_1StackVector.html">StackVector</a>&lt; double, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#a35fb524d245204c99adc811ec16e539a">solve_real_roots</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; 3, double, PolyVar &gt; &amp;f_original)</td></tr>
<tr class="memdesc:a35fb524d245204c99adc811ec16e539a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the real roots of a 3rd order <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> using radicals.  <a href="#a35fb524d245204c99adc811ec16e539a">More...</a><br /></td></tr>
<tr class="separator:a35fb524d245204c99adc811ec16e539a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a089408b9e5fd6ef4f4102952e969c"><td class="memTemplParams" colspan="2">template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </td></tr>
<tr class="memitem:a91a089408b9e5fd6ef4f4102952e969c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsym_1_1detail_1_1SturmChain.html">detail::SturmChain</a>&lt; Order, Coeff_t, PolyVar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#a91a089408b9e5fd6ef4f4102952e969c">sturm_chain</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;f)</td></tr>
<tr class="memdesc:a91a089408b9e5fd6ef4f4102952e969c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to generate a SturmChain from a <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a>.  <a href="#a91a089408b9e5fd6ef4f4102952e969c">More...</a><br /></td></tr>
<tr class="separator:a91a089408b9e5fd6ef4f4102952e969c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee847c21ce675b9feae0b56d1472a49"><td class="memTemplParams" colspan="2">template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </td></tr>
<tr class="memitem:aeee847c21ce675b9feae0b56d1472a49"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#aeee847c21ce675b9feae0b56d1472a49">descartes_rule_of_signs</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;f)</td></tr>
<tr class="memdesc:aeee847c21ce675b9feae0b56d1472a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an upper bound estimate for the number of positive real roots of a <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> (including multiples).  <a href="#aeee847c21ce675b9feae0b56d1472a49">More...</a><br /></td></tr>
<tr class="separator:aeee847c21ce675b9feae0b56d1472a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c531ce4a3adba47612bf22782170feb"><td class="memTemplParams" colspan="2">template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </td></tr>
<tr class="memitem:a0c531ce4a3adba47612bf22782170feb"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#a0c531ce4a3adba47612bf22782170feb">budan_01_test</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;f)</td></tr>
<tr class="memdesc:a0c531ce4a3adba47612bf22782170feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Budan's upper bound estimate for the number of real roots in a <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> over the range <img class="formulaInl" alt="$(0,\,1)$" src="form_75.png"/>.  <a href="#a0c531ce4a3adba47612bf22782170feb">More...</a><br /></td></tr>
<tr class="separator:a0c531ce4a3adba47612bf22782170feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e01f6b057041320e2a0f2558c948ab5"><td class="memTemplParams" colspan="2">template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </td></tr>
<tr class="memitem:a4e01f6b057041320e2a0f2558c948ab5"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#a4e01f6b057041320e2a0f2558c948ab5">alesina_galuzzi_test</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;f, const Coeff_t &amp;a, const Coeff_t &amp;b)</td></tr>
<tr class="memdesc:a4e01f6b057041320e2a0f2558c948ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alesina-Galuzzi upper bound estimate for the numer of real roots in a <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> over a specified range <img class="formulaInl" alt="$(a,\,b)$" src="form_78.png"/>.  <a href="#a4e01f6b057041320e2a0f2558c948ab5">More...</a><br /></td></tr>
<tr class="separator:a4e01f6b057041320e2a0f2558c948ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1307cda020be89404a405b88e59f9c40"><td class="memTemplParams" colspan="2">template&lt;class Coeff_t , size_t Order, class PolyVar &gt; </td></tr>
<tr class="memitem:a1307cda020be89404a405b88e59f9c40"><td class="memTemplItemLeft" align="right" valign="top">Coeff_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#a1307cda020be89404a405b88e59f9c40">LMQ_upper_bound</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;f)</td></tr>
<tr class="memdesc:a1307cda020be89404a405b88e59f9c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local-max Quadratic upper bound estimate for the value of the real roots of a <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a>.  <a href="#a1307cda020be89404a405b88e59f9c40">More...</a><br /></td></tr>
<tr class="separator:a1307cda020be89404a405b88e59f9c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d492c419fa0d08d445c2605018e965"><td class="memTemplParams" colspan="2">template&lt;class Coeff_t , size_t Order, class PolyVar &gt; </td></tr>
<tr class="memitem:a47d492c419fa0d08d445c2605018e965"><td class="memTemplItemLeft" align="right" valign="top">Coeff_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#a47d492c419fa0d08d445c2605018e965">LMQ_lower_bound</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;f)</td></tr>
<tr class="memdesc:a47d492c419fa0d08d445c2605018e965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local-max Quadratic lower bound estimate for the real roots of a <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a>.  <a href="#a47d492c419fa0d08d445c2605018e965">More...</a><br /></td></tr>
<tr class="separator:a47d492c419fa0d08d445c2605018e965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2023beed7cb4750495c80f7efb167cf4"><td class="memTemplParams" colspan="2">template&lt;class Coeff_t , class PolyVar &gt; </td></tr>
<tr class="memitem:a2023beed7cb4750495c80f7efb167cf4"><td class="memTemplItemLeft" align="right" valign="top">Coeff_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#a2023beed7cb4750495c80f7efb167cf4">LMQ_upper_bound</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; 0, Coeff_t, PolyVar &gt; &amp;f)</td></tr>
<tr class="memdesc:a2023beed7cb4750495c80f7efb167cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of Local-max Quadratic upper-bound estimation for real roots of a <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a>, where the <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> is a constant.  <a href="#a2023beed7cb4750495c80f7efb167cf4">More...</a><br /></td></tr>
<tr class="separator:a2023beed7cb4750495c80f7efb167cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3691f1507ab02a3f4c920ee35a3e022d"><td class="memTemplParams" colspan="2">template&lt;class Coeff_t , class PolyVar &gt; </td></tr>
<tr class="memitem:a3691f1507ab02a3f4c920ee35a3e022d"><td class="memTemplItemLeft" align="right" valign="top">Coeff_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#a3691f1507ab02a3f4c920ee35a3e022d">LMQ_lower_bound</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; 0, Coeff_t, PolyVar &gt; &amp;f)</td></tr>
<tr class="memdesc:a3691f1507ab02a3f4c920ee35a3e022d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of Local-max Quadratic lower-bound estimation for real roots of a <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a>, where the <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> is a constant.  <a href="#a3691f1507ab02a3f4c920ee35a3e022d">More...</a><br /></td></tr>
<tr class="separator:a3691f1507ab02a3f4c920ee35a3e022d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427e79f2856cec57c54f5dd02563cb4e"><td class="memTemplParams" colspan="2">template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </td></tr>
<tr class="memitem:a427e79f2856cec57c54f5dd02563cb4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstator_1_1orphan_1_1StackVector.html">StackVector</a>&lt; std::pair&lt; Coeff_t, Coeff_t &gt;, Order &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#a427e79f2856cec57c54f5dd02563cb4e">VCA_real_root_bounds_worker</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;f)</td></tr>
<tr class="memdesc:a427e79f2856cec57c54f5dd02563cb4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate interval bounds on all of the positive real roots between <img class="formulaInl" alt="$(0,1)$" src="form_83.png"/> of a squarefree <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a>.  <a href="#a427e79f2856cec57c54f5dd02563cb4e">More...</a><br /></td></tr>
<tr class="separator:a427e79f2856cec57c54f5dd02563cb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5683891b03388fb5131a93fb70bdf8"><td class="memTemplParams" colspan="2">template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </td></tr>
<tr class="memitem:aee5683891b03388fb5131a93fb70bdf8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstator_1_1orphan_1_1StackVector.html">StackVector</a>&lt; std::pair&lt; Coeff_t, Coeff_t &gt;, Order &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#aee5683891b03388fb5131a93fb70bdf8">VCA_real_root_bounds</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;f)</td></tr>
<tr class="memdesc:aee5683891b03388fb5131a93fb70bdf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate bounds on all of the positive real roots of a <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a>.  <a href="#aee5683891b03388fb5131a93fb70bdf8">More...</a><br /></td></tr>
<tr class="separator:aee5683891b03388fb5131a93fb70bdf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f0d655af888ae542aad0aa089f6f56"><td class="memTemplParams" colspan="2">template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </td></tr>
<tr class="memitem:ae0f0d655af888ae542aad0aa089f6f56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstator_1_1orphan_1_1StackVector.html">StackVector</a>&lt; std::pair&lt; Coeff_t, Coeff_t &gt;, Order &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#ae0f0d655af888ae542aad0aa089f6f56">VAS_real_root_bounds_worker</a> (<a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; f, <a class="el" href="structsym_1_1MobiusTransform.html">MobiusTransform</a>&lt; Coeff_t &gt; M)</td></tr>
<tr class="memdesc:ae0f0d655af888ae542aad0aa089f6f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate bounds on all of the positive real roots in the range of a <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a>.  <a href="#ae0f0d655af888ae542aad0aa089f6f56">More...</a><br /></td></tr>
<tr class="separator:ae0f0d655af888ae542aad0aa089f6f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca149415a6be49299ba0ad27fdffff68"><td class="memTemplParams" colspan="2">template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </td></tr>
<tr class="memitem:aca149415a6be49299ba0ad27fdffff68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstator_1_1orphan_1_1StackVector.html">StackVector</a>&lt; std::pair&lt; Coeff_t, Coeff_t &gt;, Order &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#aca149415a6be49299ba0ad27fdffff68">VAS_real_root_bounds</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;f)</td></tr>
<tr class="memdesc:aca149415a6be49299ba0ad27fdffff68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate bounds on all of the positive real roots of a <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a>.  <a href="#aca149415a6be49299ba0ad27fdffff68">More...</a><br /></td></tr>
<tr class="separator:aca149415a6be49299ba0ad27fdffff68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d57e4dcc33f7054fdb99275604cc6c"><td class="memTemplParams" colspan="2">template&lt;size_t Order, class Coeff_t , class PolyVar1 , class PolyVar2  = PolyVar1, typename  = typename std::enable_if&lt;(Order &gt; 2&gt; </td></tr>
<tr class="memitem:a72d57e4dcc33f7054fdb99275604cc6c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; 2, Coeff_t, typename <a class="el" href="structsym_1_1variable__combine.html">variable_combine</a>&lt; PolyVar1, PolyVar2 &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#a72d57e4dcc33f7054fdb99275604cc6c">LinBairstowSolve</a> (<a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar1 &gt; f, Coeff_t tolerance, <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; 2, Coeff_t, PolyVar2 &gt; guess={0, 0, 1})</td></tr>
<tr class="memdesc:a72d57e4dcc33f7054fdb99275604cc6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve for a quadratic factor of the passed <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> using the LinBairstow method.  <a href="#a72d57e4dcc33f7054fdb99275604cc6c">More...</a><br /></td></tr>
<tr class="separator:a72d57e4dcc33f7054fdb99275604cc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ebbc2c3139ee7ffa45130d46930ab8"><td class="memTemplParams" colspan="2">template&lt;class Coeff_t , class PolyVar1 , class PolyVar2  = PolyVar1, size_t Order&gt; </td></tr>
<tr class="memitem:a74ebbc2c3139ee7ffa45130d46930ab8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; 2, Coeff_t, PolyVar1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#a74ebbc2c3139ee7ffa45130d46930ab8">LinBairstowSolve</a> (<a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar1 &gt; f, Coeff_t tolerance, <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; 2, Coeff_t, PolyVar2 &gt; guess={0, 0, 1})</td></tr>
<tr class="memdesc:a74ebbc2c3139ee7ffa45130d46930ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve for a quadratic factor of the passed <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> using the LinBairstow method.  <a href="#a74ebbc2c3139ee7ffa45130d46930ab8">More...</a><br /></td></tr>
<tr class="separator:a74ebbc2c3139ee7ffa45130d46930ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1271325e7a24359e5e8c47daf984fd"><td class="memTemplParams" colspan="2">template&lt;class Coeff_t , size_t Order, class PolyVar &gt; </td></tr>
<tr class="memitem:aad1271325e7a24359e5e8c47daf984fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstator_1_1orphan_1_1StackVector.html">StackVector</a>&lt; Coeff_t, Order &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#aad1271325e7a24359e5e8c47daf984fd">solve_real_positive_roots_poly_sturm</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;f, const size_t tol_bits=56)</td></tr>
<tr class="memdesc:aad1271325e7a24359e5e8c47daf984fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the positive real roots of a polynomial using bisection and Sturm chains.  <a href="#aad1271325e7a24359e5e8c47daf984fd">More...</a><br /></td></tr>
<tr class="separator:aad1271325e7a24359e5e8c47daf984fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b242294f1e0635376294da4992be63"><td class="memTemplParams" colspan="2">template&lt;PolyRootBounder BoundMode, PolyRootBisector BisectionMode, size_t Order, class Coeff_t , class PolyVar &gt; </td></tr>
<tr class="memitem:a12b242294f1e0635376294da4992be63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstator_1_1orphan_1_1StackVector.html">StackVector</a>&lt; Coeff_t, Order &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#a12b242294f1e0635376294da4992be63">solve_real_positive_roots_poly</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;f)</td></tr>
<tr class="memdesc:a12b242294f1e0635376294da4992be63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterative solver for the real roots of a square-free <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a>.  <a href="#a12b242294f1e0635376294da4992be63">More...</a><br /></td></tr>
<tr class="separator:a12b242294f1e0635376294da4992be63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Polynomial set properties</div></td></tr>
<tr class="memitem:ad4830ba8c98396e5c3072e89ae069585"><td class="memTemplParams" colspan="2">template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </td></tr>
<tr class="memitem:ad4830ba8c98396e5c3072e89ae069585"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#ad4830ba8c98396e5c3072e89ae069585">empty_sum</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;)</td></tr>
<tr class="memdesc:ad4830ba8c98396e5c3072e89ae069585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the empty sum of a <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a>.  <a href="#ad4830ba8c98396e5c3072e89ae069585">More...</a><br /></td></tr>
<tr class="separator:ad4830ba8c98396e5c3072e89ae069585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Polynomial algebraic operations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>For all operations below we do not assume that we have a closure. For example, a vector multiplied by a vector is a scalar therefore the * operator may change the returned type of the polynomial. </p>
</div></td></tr>
<tr class="memitem:a3a6f50a9ba9a5a4c0d2aadb0ed5720f2"><td class="memTemplParams" colspan="2">template&lt;class Coeff_t , size_t Order, class Var1 , class Var2 , class... VarArgs, typename  = typename enable_if_var_in&lt;Var2, Var1&gt;::type&gt; </td></tr>
<tr class="memitem:a3a6f50a9ba9a5a4c0d2aadb0ed5720f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, <a class="el" href="structsym_1_1Var.html">Var</a>&lt; VarArgs... &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#a3a6f50a9ba9a5a4c0d2aadb0ed5720f2">sub</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, Var1 &gt; &amp;f, const <a class="el" href="structsym_1_1Relation.html">Relation</a>&lt; Var2, <a class="el" href="structsym_1_1Var.html">Var</a>&lt; VarArgs... &gt; &gt; &amp;x_container)</td></tr>
<tr class="memdesc:a3a6f50a9ba9a5a4c0d2aadb0ed5720f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimised <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> substitution which performs an exchange of the <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> <a class="el" href="structsym_1_1Var.html" title="Symbolic representation of a variable. ">Var</a>.  <a href="#a3a6f50a9ba9a5a4c0d2aadb0ed5720f2">More...</a><br /></td></tr>
<tr class="separator:a3a6f50a9ba9a5a4c0d2aadb0ed5720f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998b515498150d338099ddbb620eb548"><td class="memTemplParams" colspan="2">template&lt;size_t Order, class Coeff_t , class PolyVar , class SubVar , typename  = typename enable_if_var_in&lt;PolyVar, SubVar&gt;::type&gt; </td></tr>
<tr class="memitem:a998b515498150d338099ddbb620eb548"><td class="memTemplItemLeft" align="right" valign="top">Coeff_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#a998b515498150d338099ddbb620eb548">sub</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;f, const <a class="el" href="structsym_1_1Relation.html">Relation</a>&lt; SubVar, <a class="el" href="namespacesym.html#a906fb1169f4d948d53f4e868a14fe783">Null</a> &gt; &amp;)</td></tr>
<tr class="memdesc:a998b515498150d338099ddbb620eb548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimised <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> substitution for Null insertions.  <a href="#a998b515498150d338099ddbb620eb548">More...</a><br /></td></tr>
<tr class="separator:a998b515498150d338099ddbb620eb548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48af67fa52a16f26c3242ceb5ed170ea"><td class="memTemplParams" colspan="2">template&lt;class Coeff_t , size_t Order, class PolyVar , class SubVar , class Coeff_t2 , typename  = typename std::enable_if&lt;!std::is_arithmetic&lt;Coeff_t2&gt;::value                                              || (std::is_base_of&lt;Eigen::EigenBase&lt;Coeff_t2&gt;, Coeff_t2&gt;::value &amp;&amp; std::is_arithmetic&lt;Coeff_t2&gt;::value)                                              || (std::is_base_of&lt;Eigen::EigenBase&lt;Coeff_t&gt;, Coeff_t&gt;::value &amp;&amp; std::is_arithmetic&lt;Coeff_t2&gt;::value)                                              &gt;::type, typename  = typename enable_if_var_in&lt;PolyVar, SubVar&gt;::type&gt; </td></tr>
<tr class="memitem:a48af67fa52a16f26c3242ceb5ed170ea"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#a48af67fa52a16f26c3242ceb5ed170ea">sub</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;f, const <a class="el" href="structsym_1_1Relation.html">Relation</a>&lt; SubVar, Coeff_t2 &gt; &amp;x_container) -&gt; <a class="el" href="config_8hpp.html#aba3f0e2e567a0a1cedd890915cd5b7c5">STATOR_AUTORETURN</a>(<a class="el" href="structsym_1_1detail_1_1PolySubWorker.html">detail::PolySubWorker</a>&lt; Order &gt;::eval(f, x_container._val)) template&lt; size_t D, size_t Order, class Coeff_t, class PolyVar, class Coeff_t2 &gt;std::array&lt; Coeff_t, D+1 &gt; eval_derivatives(const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;f, const Coeff_t2 &amp;x)</td></tr>
<tr class="memdesc:a48af67fa52a16f26c3242ceb5ed170ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolically evaluates a <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> expression.  <a href="#a48af67fa52a16f26c3242ceb5ed170ea">More...</a><br /></td></tr>
<tr class="separator:a48af67fa52a16f26c3242ceb5ed170ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff50b1dbed047fd3fed0c516d8933a1e"><td class="memTemplParams" colspan="2">template&lt;size_t Order1, class Coeff_t , class PolyVar1 , class PolyVar2 , size_t Order2, typename  = typename enable_if_var_in&lt;PolyVar1, PolyVar2&gt;::type&gt; </td></tr>
<tr class="memitem:aff50b1dbed047fd3fed0c516d8933a1e"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order1, Coeff_t, typename <a class="el" href="structsym_1_1variable__combine.html">variable_combine</a>&lt; PolyVar1, PolyVar2 &gt;::type &gt;, <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order2-1, Coeff_t, typename <a class="el" href="structsym_1_1variable__combine.html">variable_combine</a>&lt; PolyVar1, PolyVar2 &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#aff50b1dbed047fd3fed0c516d8933a1e">gcd</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order1, Coeff_t, PolyVar1 &gt; &amp;f, const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order2, Coeff_t, PolyVar2 &gt; &amp;g)</td></tr>
<tr class="memdesc:aff50b1dbed047fd3fed0c516d8933a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform Euclidean division of a polynomial.  <a href="#aff50b1dbed047fd3fed0c516d8933a1e">More...</a><br /></td></tr>
<tr class="separator:aff50b1dbed047fd3fed0c516d8933a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3172f0edb615f26680074e26de7f7a2d"><td class="memTemplParams" colspan="2">template&lt;size_t Order1, class Coeff_t , class PolyVar1 , class PolyVar2 , typename  = typename enable_if_var_in&lt;PolyVar1, PolyVar2&gt;::type&gt; </td></tr>
<tr class="memitem:a3172f0edb615f26680074e26de7f7a2d"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order1, Coeff_t, typename <a class="el" href="structsym_1_1variable__combine.html">variable_combine</a>&lt; PolyVar1, PolyVar2 &gt;::type &gt;, <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; 0, Coeff_t, typename <a class="el" href="structsym_1_1variable__combine.html">variable_combine</a>&lt; PolyVar1, PolyVar2 &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#a3172f0edb615f26680074e26de7f7a2d">gcd</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order1, Coeff_t, PolyVar1 &gt; &amp;f, const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; 0, Coeff_t, PolyVar2 &gt; &amp;g)</td></tr>
<tr class="memdesc:a3172f0edb615f26680074e26de7f7a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation for division by a constant.  <a href="#a3172f0edb615f26680074e26de7f7a2d">More...</a><br /></td></tr>
<tr class="separator:a3172f0edb615f26680074e26de7f7a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Polynomial calculus operations</div></td></tr>
<tr class="memitem:ae351d04a9d403044ed0c5cf07b33e970"><td class="memTemplParams" colspan="2">template&lt;class PolyVar , class... VarArgs, class Coeff_t , size_t N, typename  = typename std::enable_if&lt;(N &gt; 0&gt; </td></tr>
<tr class="memitem:ae351d04a9d403044ed0c5cf07b33e970"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; <a class="el" href="namespacesym.html#a9001edc8c0de50043e7e2cda991e2519">N</a>-1, Coeff_t, typename <a class="el" href="structsym_1_1variable__combine.html">variable_combine</a>&lt; PolyVar, <a class="el" href="structsym_1_1Var.html">Var</a>&lt; VarArgs... &gt; &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#ae351d04a9d403044ed0c5cf07b33e970">derivative</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; <a class="el" href="namespacesym.html#a9001edc8c0de50043e7e2cda991e2519">N</a>, Coeff_t, PolyVar &gt; &amp;f, <a class="el" href="structsym_1_1Var.html">Var</a>&lt; VarArgs... &gt;)</td></tr>
<tr class="memdesc:ae351d04a9d403044ed0c5cf07b33e970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivatives of <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> types.  <a href="#ae351d04a9d403044ed0c5cf07b33e970">More...</a><br /></td></tr>
<tr class="separator:ae351d04a9d403044ed0c5cf07b33e970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae408df9721e673cc67275d67c87680"><td class="memTemplParams" colspan="2">template&lt;class PolyVar , class... VarArgs, class Coeff_t , size_t N, typename  = typename std::enable_if&lt;(N==0) || (!variable_in&lt;PolyVar, Var&lt;VarArgs...&gt; &gt;::value)&gt;::type&gt; </td></tr>
<tr class="memitem:a3ae408df9721e673cc67275d67c87680"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesym.html#a906fb1169f4d948d53f4e868a14fe783">Null</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#a3ae408df9721e673cc67275d67c87680">derivative</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; <a class="el" href="namespacesym.html#a9001edc8c0de50043e7e2cda991e2519">N</a>, Coeff_t, PolyVar &gt; &amp;f, <a class="el" href="structsym_1_1Var.html">Var</a>&lt; VarArgs... &gt;)</td></tr>
<tr class="memdesc:a3ae408df9721e673cc67275d67c87680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivatives of <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> types.  <a href="#a3ae408df9721e673cc67275d67c87680">More...</a><br /></td></tr>
<tr class="separator:a3ae408df9721e673cc67275d67c87680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Polynomial input/output operations</div></td></tr>
<tr class="memitem:ae872d2ebb6bdf64fae7458b4f629fcc8"><td class="memTemplParams" colspan="2">template&lt;class Coeff_t , size_t N, class PolyVar &gt; </td></tr>
<tr class="memitem:ae872d2ebb6bdf64fae7458b4f629fcc8"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#ae872d2ebb6bdf64fae7458b4f629fcc8">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; <a class="el" href="namespacesym.html#a9001edc8c0de50043e7e2cda991e2519">N</a>, Coeff_t, PolyVar &gt; &amp;poly)</td></tr>
<tr class="memdesc:ae872d2ebb6bdf64fae7458b4f629fcc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a human-readable representation of the <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> to the output stream.  <a href="#ae872d2ebb6bdf64fae7458b4f629fcc8">More...</a><br /></td></tr>
<tr class="separator:ae872d2ebb6bdf64fae7458b4f629fcc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Polynomial transformations</div></td></tr>
<tr class="memitem:a00fe9fed3535887ddf96ad9d9010d7df"><td class="memTemplParams" colspan="2">template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </td></tr>
<tr class="memitem:a00fe9fed3535887ddf96ad9d9010d7df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, double, PolyVar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#a00fe9fed3535887ddf96ad9d9010d7df">shift_function</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;f, const double t)</td></tr>
<tr class="memdesc:a00fe9fed3535887ddf96ad9d9010d7df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a polynomial <img class="formulaInl" alt="$g(x)=f(x+t)$" src="form_23.png"/>.  <a href="#a00fe9fed3535887ddf96ad9d9010d7df">More...</a><br /></td></tr>
<tr class="separator:a00fe9fed3535887ddf96ad9d9010d7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6749b6b613fc59162e3fb302f9d51c44"><td class="memTemplParams" colspan="2">template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </td></tr>
<tr class="memitem:a6749b6b613fc59162e3fb302f9d51c44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#a6749b6b613fc59162e3fb302f9d51c44">shift_function</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;f, <a class="el" href="namespacesym.html#ad051764c07e9b8c84b6a313f99026631">Unity</a>)</td></tr>
<tr class="memdesc:a6749b6b613fc59162e3fb302f9d51c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a polynomial <img class="formulaInl" alt="$g(x)=f(x+1)$" src="form_34.png"/>.  <a href="#a6749b6b613fc59162e3fb302f9d51c44">More...</a><br /></td></tr>
<tr class="separator:a6749b6b613fc59162e3fb302f9d51c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829978b210f4e4f2a360ec279bf1e0d4"><td class="memTemplParams" colspan="2">template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </td></tr>
<tr class="memitem:a829978b210f4e4f2a360ec279bf1e0d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#a829978b210f4e4f2a360ec279bf1e0d4">invert_taylor_shift</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;f)</td></tr>
<tr class="memdesc:a829978b210f4e4f2a360ec279bf1e0d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a polynomial <img class="formulaInl" alt="$g(x)=(x+1)^{d} f\left(\frac{1}{x+1}\right)$" src="form_35.png"/>.  <a href="#a829978b210f4e4f2a360ec279bf1e0d4">More...</a><br /></td></tr>
<tr class="separator:a829978b210f4e4f2a360ec279bf1e0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47ed1938e5708828a1b6cab0ab17949"><td class="memTemplParams" colspan="2">template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </td></tr>
<tr class="memitem:ad47ed1938e5708828a1b6cab0ab17949"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#ad47ed1938e5708828a1b6cab0ab17949">reflect_poly</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;f)</td></tr>
<tr class="memdesc:ad47ed1938e5708828a1b6cab0ab17949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a polynomial <img class="formulaInl" alt="$g(x)=f\left(-x\right)$" src="form_43.png"/>.  <a href="#ad47ed1938e5708828a1b6cab0ab17949">More...</a><br /></td></tr>
<tr class="separator:ad47ed1938e5708828a1b6cab0ab17949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad12fb169acb07394ae09266567c304d"><td class="memTemplParams" colspan="2">template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </td></tr>
<tr class="memitem:aad12fb169acb07394ae09266567c304d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsym_1_1Polynomial.html#aad12fb169acb07394ae09266567c304d">scale_poly</a> (const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;f, const Coeff_t &amp;a)</td></tr>
<tr class="memdesc:aad12fb169acb07394ae09266567c304d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a polynomial <img class="formulaInl" alt="$g(x)=f\left(a\,x\right)$" src="form_44.png"/> where <img class="formulaInl" alt="$a$" src="form_22.png"/> is the scaling factor.  <a href="#aad12fb169acb07394ae09266567c304d">More...</a><br /></td></tr>
<tr class="separator:aad12fb169acb07394ae09266567c304d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;size_t Order, class Coeff_t, class PolyVar&gt;<br />
class sym::Polynomial&lt; Order, Coeff_t, PolyVar &gt;</h3>

<p>This class allows basic computer algebra to be performed with <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> equations.</p>
<p>For example, the polynomial <img class="formulaInl" alt="$f(x)=x^2 + 2\,x + 3$" src="form_12.png"/> can be created like so: </p><div class="fragment"><div class="line">Polynomial&lt;1&gt; x{0,1};</div><div class="line"><span class="keyword">auto</span> f = x*x + 2*x +3;    </div></div><!-- fragment --><p> And evaluated at the point <img class="formulaInl" alt="$x=3$" src="form_13.png"/> like so: </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> val = f(3);    </div></div><!-- fragment --><p>The class also functions with Eigen vector or matrix coefficients.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Order</td><td>The order of the <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a>.</td></tr>
    <tr><td class="paramname">Coeff_t</td><td>The type of the coefficients of the <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l00063">63</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0178f8426d39faf229a644966db572ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Order, class Coeff_t, class PolyVar&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsym_1_1Polynomial.html">sym::Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt;::<a class="el" href="classsym_1_1Polynomial.html">Polynomial</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This initialises all <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> orders to be equivalent to zero. </p>

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l00074">74</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6be259aa9b118a35d6e684da3348b537"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Order, class Coeff_t, class PolyVar&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsym_1_1Polynomial.html">sym::Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt;::<a class="el" href="classsym_1_1Polynomial.html">Polynomial</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; Coeff_t &gt;&#160;</td>
          <td class="paramname"><em>_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This allows a polynomial to be constructed using just a list of coefficients. E.g. </p><div class="fragment"><div class="line">Polynomial&lt;1&gt; f{0.5,1,2};</div><div class="line"><span class="comment">//f = 2 * x*x + x + 0.5;</span></div></div><!-- fragment --> 
<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l00086">86</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af8e4c013e631aab032ab4791f2d05375"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Order, class Coeff_t, class PolyVar&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsym_1_1Polynomial.html">sym::Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt;::<a class="el" href="classsym_1_1Polynomial.html">Polynomial</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l00099">99</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a678dfc42d06abd4e8450d714f0c6147b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Order, class Coeff_t, class PolyVar&gt; </div>
<div class="memtemplate">
template&lt;size_t N, class Coeff_t2 , class PolyVar2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsym_1_1Polynomial.html">sym::Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt;::<a class="el" href="classsym_1_1Polynomial.html">Polynomial</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; <a class="el" href="namespacesym.html#a9001edc8c0de50043e7e2cda991e2519">N</a>, Coeff_t2, PolyVar2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l00117">117</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a73e2900178885c27cb1c299f404b126c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Order, class Coeff_t, class PolyVar&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a> <a class="el" href="classsym_1_1Polynomial.html">sym::Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l00126">126</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a4e01f6b057041320e2a0f2558c948ab5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t alesina_galuzzi_test </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coeff_t &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coeff_t &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This a generalisation of Budan's 01 test (see <a class="el" href="classsym_1_1Polynomial.html#a0c531ce4a3adba47612bf22782170feb">budan_01_test</a>) and is implemented that way. The polynomial is shifted so that <img class="formulaInl" alt="$0$" src="form_79.png"/> corresponds to <img class="formulaInl" alt="$a$" src="form_22.png"/>, then scaled so that <img class="formulaInl" alt="$x=1$" src="form_80.png"/> corresponds to <img class="formulaInl" alt="$b$" src="form_81.png"/>, before Budan's test is called on the transformed <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a>. </p>

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l01281">1281</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0c531ce4a3adba47612bf22782170feb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t budan_01_test </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Budan's test is actually just Descarte's test, but on a transformed <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> <img class="formulaInl" alt="$p(x)$" src="form_36.png"/>, which is related to <img class="formulaInl" alt="$f(x)$" src="form_16.png"/> as follows:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ p(x) = \left(x+1\right)^d\,f\left(\frac{1}{x+1}\right) \]" src="form_37.png"/>
</p>
<p>where <img class="formulaInl" alt="$d$" src="form_38.png"/> is the order of the polynomial <img class="formulaInl" alt="$f(x)$" src="form_16.png"/>. The roots of <img class="formulaInl" alt="$f(x)$" src="form_16.png"/> in the range <img class="formulaInl" alt="$[0,1]$" src="form_76.png"/> are mapped over the range <img class="formulaInl" alt="$[0,\infty]$" src="form_77.png"/> of <img class="formulaInl" alt="$p(x)$" src="form_36.png"/>. This allows Descarte's rule of signs to be applied to a limited range of the original polynomial.</p>
<p>The actual transformation to <img class="formulaInl" alt="$p(x)$" src="form_36.png"/> is carried out using the <a class="el" href="classsym_1_1Polynomial.html#a829978b210f4e4f2a360ec279bf1e0d4">invert_taylor_shift</a> function, before this is passed to <a class="el" href="classsym_1_1Polynomial.html#aeee847c21ce675b9feae0b56d1472a49">descartes_rule_of_signs</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>An upper bound on the number of real roots in the interval <img class="formulaInl" alt="$(0,\,1)$" src="form_75.png"/>. </dd></dl>

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l01266">1266</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abceed2e1f15d2a0f1a50943806c4b853"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order-1, Coeff_t, PolyVar &gt; deflate_polynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a polynomial, we can rearrange it in factored form like so </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sum_{i=0}^N a_i\,x^i =(x - r_1)\sum_{i=0}^{N-1} b_i\, x^{i} \]" src="form_45.png"/>
</p>
<p>where <img class="formulaInl" alt="$r_1$" src="form_46.png"/> is a root of the polynomial. Equating terms on the LHS with terms on the RHS with equal powers of <img class="formulaInl" alt="$x$" src="form_0.png"/>, we have:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ b_i=\frac{b_{i-1} - a_i}{r_1}\qquad \textrm{for}\ i\in[1,\,N-1] \]" src="form_47.png"/>
</p>
<p>This formula, known as backward deflation, can be used to calculate all coefficients using the starting point <img class="formulaInl" alt="$b_0=-a_0 / r_1$" src="form_48.png"/>. This approach is not always stable (for example if the root is zero, or if <img class="formulaInl" alt="$b_{i-1}$" src="form_49.png"/> has the same sign as <img class="formulaInl" alt="$a_i$" src="form_50.png"/> we might have catastrophic cancellation).</p>
<p>An alternative "forward" iterative form may be found by substituting <img class="formulaInl" alt="$i\to i+1$" src="form_51.png"/>, which gives:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ b_{i} = a_{i+1} + r_1\,b_{i+1} \qquad \textrm{for}\ i\in[0,\,N-2] \]" src="form_52.png"/>
</p>
<p>Again this approach may be used given the starting point <img class="formulaInl" alt="$b_{N-1}=a_N$" src="form_53.png"/>. However, it might also suffer from catastrophic cancellation if <img class="formulaInl" alt="$a_{i+1}$" src="form_54.png"/> has the opposite sign to <img class="formulaInl" alt="$r_1\,b_{i+1}$" src="form_55.png"/>.</p>
<p>It should be noted that Numerical Recipies states that "Forward deflation is stable if the largest absolute root is always divided out... backward deflation is stable if the smallest absolute root is always divided out". Unfortunately we do not know a priori the magnitude of the root being divided out.</p>
<p>As both approaches may suffer from catastrophic cancellation, we decide to switch between them. If we catch the special root-is-zero case, we only must avoid catastrophic cancellation. This arises if two non-zero terms are subtracted from each other (i.e., for the first approach this happens if <img class="formulaInl" alt="$a_{i+1}$" src="form_54.png"/> and <img class="formulaInl" alt="$r_1\,b_{i+1}$" src="form_55.png"/> are non-zero and have opposite sign). We could use this to monitor the bits of precision "lost" as we calculate from each end and select a point between the two methods where accuracy is highest, but this would require a more detailed analysis of the error. A simple approach is to solve from both ends of the polynomial at the same time and only actually accept whichever has the lowest catastrophic cancellation accuracy in terms of bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> to factor a root out of. </td></tr>
    <tr><td class="paramname">root</td><td>The root to remove. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l00720">720</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5463d42e10f39ce3d00504eaf2eafb8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order-1, Coeff_t, PolyVar &gt; deflate_polynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesym.html#a906fb1169f4d948d53f4e868a14fe783">Null</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deflating out a root at zero becomes a division by x. As the constant term is zero, there is no residual and the division becomes a simple shifted copy. </p>

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l00753">753</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae351d04a9d403044ed0c5cf07b33e970"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PolyVar , class... VarArgs, class Coeff_t , size_t N, typename  = typename std::enable_if&lt;(N &gt; 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; <a class="el" href="namespacesym.html#a9001edc8c0de50043e7e2cda991e2519">N</a>-1, Coeff_t, typename <a class="el" href="structsym_1_1variable__combine.html">variable_combine</a>&lt; PolyVar, <a class="el" href="structsym_1_1Var.html">Var</a>&lt; VarArgs... &gt; &gt;::type &gt; derivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; <a class="el" href="namespacesym.html#a9001edc8c0de50043e7e2cda991e2519">N</a>, Coeff_t, PolyVar &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsym_1_1Var.html">Var</a>&lt; VarArgs... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This specialisation is only activated if this is a derivative in the correct variable AND the Order of the <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> is greater than zero. </p>

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l00402">402</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3ae408df9721e673cc67275d67c87680"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PolyVar , class... VarArgs, class Coeff_t , size_t N, typename  = typename std::enable_if&lt;(N==0) || (!variable_in&lt;PolyVar, Var&lt;VarArgs...&gt; &gt;::value)&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesym.html#a906fb1169f4d948d53f4e868a14fe783">Null</a> derivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; <a class="el" href="namespacesym.html#a9001edc8c0de50043e7e2cda991e2519">N</a>, Coeff_t, PolyVar &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsym_1_1Var.html">Var</a>&lt; VarArgs... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This specialisation is only activated if this is a derivative in the incorrect variable OR its a low order poly. </p>

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l00417">417</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeee847c21ce675b9feae0b56d1472a49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t descartes_rule_of_signs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Descarte's rule of signs states that the number of positive real roots for a single-variable real-coefficient <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> is less than or equal to the number of sign changes between consecutive non-zero coefficients in the <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a>. When the actual root count is less, it is less by an even number. Therefore, the values 0 or 1 are exact. </p>

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l01229">1229</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad4830ba8c98396e5c3072e89ae069585"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; empty_sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The empty sum is a term whose multiplicative action is null (can be ignored). </p>

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l00159">159</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aff50b1dbed047fd3fed0c516d8933a1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Order1, class Coeff_t , class PolyVar1 , class PolyVar2 , size_t Order2, typename  = typename enable_if_var_in&lt;PolyVar1, PolyVar2&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order1, Coeff_t, typename <a class="el" href="structsym_1_1variable__combine.html">variable_combine</a>&lt; PolyVar1, PolyVar2 &gt;::type &gt;, <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order2-1, Coeff_t, typename <a class="el" href="structsym_1_1variable__combine.html">variable_combine</a>&lt; PolyVar1, PolyVar2 &gt;::type &gt; &gt; gcd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order1, Coeff_t, PolyVar1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order2, Coeff_t, PolyVar2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given two polynomials <img class="formulaInl" alt="$f(x)$" src="form_16.png"/> and <img class="formulaInl" alt="$g(x)$" src="form_17.png"/>, the Euclidean division is a determination of the quotient polynomial <img class="formulaInl" alt="$q(x)$" src="form_18.png"/> and the remainder polynomial <img class="formulaInl" alt="$r(x)$" src="form_19.png"/>, which satisfy</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(x) = g(x)\,q(x) + r(x) \]" src="form_20.png"/>
</p>
<p>If g(x) only consists of factors of f(x), the remainder will be zero. The algorithm used here is based on polynomial long division.</p>
<p>If the division is by a monomial <img class="formulaInl" alt="$g(x)=(x-a)$" src="form_21.png"/> where <img class="formulaInl" alt="$a$" src="form_22.png"/> is a root of <img class="formulaInl" alt="$f(x)$" src="form_16.png"/>, then the deflate_polynomial function should be used as it is more numerically stable and efficient.</p>
<p>As g(x) may contain leading order coefficients which are zero, we cannot lower the order of the quotient polynomial returned. </p>

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l00340">340</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3172f0edb615f26680074e26de7f7a2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Order1, class Coeff_t , class PolyVar1 , class PolyVar2 , typename  = typename enable_if_var_in&lt;PolyVar1, PolyVar2&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order1, Coeff_t, typename <a class="el" href="structsym_1_1variable__combine.html">variable_combine</a>&lt; PolyVar1, PolyVar2 &gt;::type &gt;, <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; 0, Coeff_t, typename <a class="el" href="structsym_1_1variable__combine.html">variable_combine</a>&lt; PolyVar1, PolyVar2 &gt;::type &gt; &gt; gcd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order1, Coeff_t, PolyVar1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; 0, Coeff_t, PolyVar2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l00375">375</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a829978b210f4e4f2a360ec279bf1e0d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; invert_taylor_shift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The creation of <img class="formulaInl" alt="$p(x)$" src="form_36.png"/>, given by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ p(x) = \left(x+1\right)^d\,f\left(\frac{1}{x+1}\right) \]" src="form_37.png"/>
</p>
<p>where <img class="formulaInl" alt="$d$" src="form_38.png"/> is the order of the polynomial <img class="formulaInl" alt="$f(x)$" src="form_16.png"/>, is often carried out while locating roots of a <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a>. It has the useful property of generating a polynomial which has the same number of roots of <img class="formulaInl" alt="$f(x)$" src="form_16.png"/> in the range <img class="formulaInl" alt="$x\in[0,\,1]$" src="form_39.png"/>, but now in the range <img class="formulaInl" alt="$x\in[\infty,\,0]$" src="form_40.png"/>. Therefore, small sections of a polynomial may be inspected for roots using scaling, shifting, and this transformation. It is a special case of a Mobius transformation of the <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a>.</p>
<p>Creation of <img class="formulaInl" alt="$p(x)$" src="form_36.png"/> may be carried out in two steps. First, the following equation is generated:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ p_1(x) = x^d\,f\left(\frac{1}{x}\right) \]" src="form_41.png"/>
</p>
<p>This operation may be performed simply by reversing the order of the coefficient array in the <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a>. Then, a <a class="el" href="classsym_1_1Polynomial.html#a00fe9fed3535887ddf96ad9d9010d7df">shift_function</a> is applied to complete the transformation:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ p_2(x) = p_1\left(x+1\right) \]" src="form_42.png"/>
</p>
<p>This entire operation is performed using an optimised version of the shift_polynomial function. Take a look at the implementation of shift_polynomial and substitute in a shift value of 1 to arrive at this implementation. </p>

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l00590">590</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a72d57e4dcc33f7054fdb99275604cc6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Order, class Coeff_t , class PolyVar1 , class PolyVar2  = PolyVar1, typename  = typename std::enable_if&lt;(Order &gt; 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; 2, Coeff_t, typename <a class="el" href="structsym_1_1variable__combine.html">variable_combine</a>&lt; PolyVar1, PolyVar2 &gt;::type &gt; LinBairstowSolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar1 &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coeff_t&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; 2, Coeff_t, PolyVar2 &gt;&#160;</td>
          <td class="paramname"><em>guess</em> = <code>{0,0,1}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is part of a generic polynomial root finding technique. It returns a quadratic factor of the passed polynomial. The tolerance is the convergence criterion on the coefficients of the factor. </p>

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l01682">1682</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a74ebbc2c3139ee7ffa45130d46930ab8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Coeff_t , class PolyVar1 , class PolyVar2  = PolyVar1, size_t Order&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; 2, Coeff_t, PolyVar1 &gt; LinBairstowSolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar1 &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coeff_t&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; 2, Coeff_t, PolyVar2 &gt;&#160;</td>
          <td class="paramname"><em>guess</em> = <code>{0,0,1}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This specialisation is for low-order polynomials, where there is no factorisation to be done and the original </p>

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l01729">1729</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a47d492c419fa0d08d445c2605018e965"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Coeff_t , size_t Order, class PolyVar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Coeff_t LMQ_lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> <img class="formulaInl" alt="$f(x)$" src="form_16.png"/>, this function performs the transformation:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ g(x) = x^n\,f(\frac{1}{x}) \]" src="form_82.png"/>
</p>
<p>Now the upper bound on the real roots of <img class="formulaInl" alt="$g(x)$" src="form_17.png"/> are the inverse of the lower bound on the real roots of <img class="formulaInl" alt="$f(x)$" src="form_16.png"/>. The transformation is computationally equivalent to reversing the coefficient array of the polynomial <img class="formulaInl" alt="$f(x)$" src="form_16.png"/>. This function is adapted from the thesis "Upper bounds on the values of the
positive roots of polynomials" by Panagiotis S. Vigklas (2010). </p>

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l01337">1337</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3691f1507ab02a3f4c920ee35a3e022d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Coeff_t , class PolyVar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Coeff_t LMQ_lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; 0, Coeff_t, PolyVar &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l01357">1357</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1307cda020be89404a405b88e59f9c40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Coeff_t , size_t Order, class PolyVar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Coeff_t LMQ_upper_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is adapted from the thesis "Upper bounds on the
values of the positive roots of polynomials" by Panagiotis S. Vigklas (2010). The main change is to generalise to arbitrary sign on the highest order coefficient, and to allow high-order coefficients with zero values. </p>

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l01295">1295</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2023beed7cb4750495c80f7efb167cf4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Coeff_t , class PolyVar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Coeff_t LMQ_upper_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; 0, Coeff_t, PolyVar &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l01347">1347</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae872d2ebb6bdf64fae7458b4f629fcc8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Coeff_t , size_t N, class PolyVar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; <a class="el" href="namespacesym.html#a9001edc8c0de50043e7e2cda991e2519">N</a>, Coeff_t, PolyVar &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l00454">454</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0aecceaf5e103c3ed975c7f650619090"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Order, class Coeff_t, class PolyVar&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classsym_1_1Polynomial.html#a0aecceaf5e103c3ed975c7f650619090">PolyRootBisector</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l01666">1666</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5bfe1fe4dfe312a968062393a59c6afc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Order, class Coeff_t, class PolyVar&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classsym_1_1Polynomial.html#a5bfe1fe4dfe312a968062393a59c6afc">PolyRootBounder</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l01660">1660</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7f7e992dadc5d5ea4b1cfca9ddd8e50c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Coeff_t , size_t Order, class Coeff_t2 , class PolyVar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Coeff_t precision </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coeff_t2 &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The calculation of this value is outlined in "5.6 Root
acceptance and refinement" of "A survey of numerical
mathematics" vol.1. It is useful for setting accuracy limits while calculating roots. </p>

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l00639">639</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad47ed1938e5708828a1b6cab0ab17949"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; reflect_poly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l00604">604</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aad12fb169acb07394ae09266567c304d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; scale_poly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coeff_t &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l00615">615</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a00fe9fed3535887ddf96ad9d9010d7df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, double, PolyVar &gt; shift_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a polynomial <img class="formulaInl" alt="$f(x)$" src="form_16.png"/>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(x) = \sum_{i=0}^N a_i\,x^i \]" src="form_24.png"/>
</p>
<p>We wish to determine the coefficients of a polynomial <img class="formulaInl" alt="$g(x)=f(x+t)$" src="form_23.png"/>:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ g(x) = \sum_{i=0}^N b_i\,x^i \]" src="form_25.png"/>
</p>
<p>We can define <img class="formulaInl" alt="$g(x)$" src="form_17.png"/> by taking a Taylor expansion of <img class="formulaInl" alt="$f(x)$" src="form_16.png"/> about the point <img class="formulaInl" alt="$t$" src="form_26.png"/>, we have:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ g(x) = f(t+x) = \sum_{i=0}^N \frac{f^i(t)}{i!}x^i \]" src="form_27.png"/>
</p>
<p>where <img class="formulaInl" alt="$f^i(x)$" src="form_28.png"/> is the <img class="formulaInl" alt="$i$" src="form_29.png"/>th derivative of <img class="formulaInl" alt="$f(x)$" src="form_16.png"/> and <img class="formulaInl" alt="$N$" src="form_30.png"/> is the order of the polynomial <img class="formulaInl" alt="$f$" src="form_31.png"/>. Each coefficient of <img class="formulaInl" alt="$g$" src="form_32.png"/> is then given by:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ b_i = \frac{f^i(t)}{i!} \]" src="form_33.png"/>
</p>
<p>Here, we then use a modified version of the eval_derivatives function to actually calculate the derivatives while avoiding the factorial term. </p>

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l00518">518</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6749b6b613fc59162e3fb302f9d51c44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; shift_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesym.html#ad051764c07e9b8c84b6a313f99026631">Unity</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an optimised <a class="el" href="classsym_1_1Polynomial.html#a00fe9fed3535887ddf96ad9d9010d7df">shift_function</a> operation where the shift is unity. See <a class="el" href="classsym_1_1Polynomial.html#a00fe9fed3535887ddf96ad9d9010d7df">shift_function</a> for more implementation details. </p>

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l00540">540</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a942b02dde4542b8da603da9abbb64bfc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config  = DefaultSimplifyConfig, class PolyVar , class... VarArgs, size_t Order, class Real , typename  = typename std::enable_if&lt;Config::expand_to_Polynomial &amp;&amp; variable_in&lt;Var&lt;VarArgs...&gt;, PolyVar&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order+1, Real, PolyVar &gt; simplify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesym.html#a866e1c4e67928b4dc39ed6d99b2dd164">MultiplyOp</a>&lt; <a class="el" href="structsym_1_1Var.html">Var</a>&lt; VarArgs... &gt;, <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Real, PolyVar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This general form allows all operations between all constants.</p>
<p>Simplification of a <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> LHS multiplied by a <a class="el" href="structsym_1_1Var.html" title="Symbolic representation of a variable. ">Var</a>. </p>

<p>Definition at line <a class="el" href="simplify_8hpp_source.html#l00267">267</a> of file <a class="el" href="simplify_8hpp_source.html">simplify.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a12b242294f1e0635376294da4992be63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PolyRootBounder BoundMode, PolyRootBisector BisectionMode, size_t Order, class Coeff_t , class PolyVar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstator_1_1orphan_1_1StackVector.html">StackVector</a>&lt; Coeff_t, Order &gt; solve_real_positive_roots_poly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function assumes that the polynomial has non-zero high and constant coefficients. </p>

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l01837">1837</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aad1271325e7a24359e5e8c47daf984fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Coeff_t , size_t Order, class PolyVar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstator_1_1orphan_1_1StackVector.html">StackVector</a>&lt; Coeff_t, Order &gt; solve_real_positive_roots_poly_sturm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>tol_bits</em> = <code>56</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l01739">1739</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aee4ec7d0395e3cbff42ed49086ddcac2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PolyVar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstator_1_1orphan_1_1StackVector.html">StackVector</a>&lt; double, 0 &gt; solve_real_roots </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; 0, double, PolyVar &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> to evaluate. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l00765">765</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a787fe2e8facef3b1a5de5bc4e94d4752"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PolyVar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstator_1_1orphan_1_1StackVector.html">StackVector</a>&lt; double, 1 &gt; solve_real_roots </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; 1, double, PolyVar &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> to evaluate. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l00775">775</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaaf5e18eb8d2b66f673774bc0732fdd6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PolyVar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstator_1_1orphan_1_1StackVector.html">StackVector</a>&lt; double, 2 &gt; solve_real_roots </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; 2, double, PolyVar &gt;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Roots are always returned sorted lowest-first.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> to evaluate. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l00790">790</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a35fb524d245204c99adc811ec16e539a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PolyVar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstator_1_1orphan_1_1StackVector.html">StackVector</a>&lt; double, 3 &gt; solve_real_roots </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; 3, double, PolyVar &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_original</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Roots are always returned sorted lowest-first.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f_original</td><td>The <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> to evaluate. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l00865">865</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a91a089408b9e5fd6ef4f4102952e969c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsym_1_1detail_1_1SturmChain.html">detail::SturmChain</a>&lt; Order, Coeff_t, PolyVar &gt; sturm_chain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The actual calculation, storage, and evaluation of the Sturm chain is done by the <a class="el" href="structsym_1_1detail_1_1SturmChain.html" title="A collection of Polynomials which form a Sturm chain. ">detail::SturmChain</a> type.</p>
<p>The Sturm chain is a sequence of polynomials <img class="formulaInl" alt="$p_0(x)$" src="form_56.png"/>, <img class="formulaInl" alt="$p_1(x)$" src="form_57.png"/>, <img class="formulaInl" alt="$p_2(x)$" src="form_58.png"/>, <img class="formulaInl" alt="$\ldots$" src="form_59.png"/>, <img class="formulaInl" alt="$p_n(x)$" src="form_60.png"/> generated from a single polynomial <img class="formulaInl" alt="$f(x)$" src="form_16.png"/> of order <img class="formulaInl" alt="$n$" src="form_61.png"/>. The first two Sturm chain polynomials are given as</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} p_0(x) &amp;=&amp; f(x)\\ p_1(x) &amp;=&amp; f'(x) \end{eqnarray*}" src="form_62.png"/>
</p>
<p>All higher polynomials are evaluated like so:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} p_n(x) &amp;=&amp; -\mathrm{rem}(p_{n-2}, p_{n-1}) \end{eqnarray*}" src="form_63.png"/>
</p>
<p>where <img class="formulaInl" alt="$\mathrm{rem}(p_{n+2},\,p_{n+1})$" src="form_64.png"/> returns the remainder polynomial from a <a class="el" href="classsym_1_1Polynomial.html#aff50b1dbed047fd3fed0c516d8933a1e">gcd</a> of <img class="formulaInl" alt="$p_{n+2}$" src="form_65.png"/> over <img class="formulaInl" alt="$p_{n+1}$" src="form_66.png"/>. This sequence terminates at <img class="formulaInl" alt="$p_N$" src="form_67.png"/>, where <img class="formulaInl" alt="$N$" src="form_30.png"/> is the order of the original <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a>, <img class="formulaInl" alt="$f(x)$" src="form_16.png"/>.</p>
<p>The interesting property of this chain is that it allows a calculation of the count of distinct real roots of <img class="formulaInl" alt="$f(x)$" src="form_16.png"/> within a certain range. If we evaluate the Sturm chain of <img class="formulaInl" alt="$f(x)$" src="form_16.png"/> at a point <img class="formulaInl" alt="$\xi$" src="form_68.png"/> and count the number of changes in sign (ignoring zeros) in the sequence:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ p_0(\xi),\,p_1(\xi),\,\ldots p_n(\xi) \]" src="form_69.png"/>
</p>
<p>and define this as <img class="formulaInl" alt="$\sigma(\xi)$" src="form_70.png"/>. Then, given two real numbers <img class="formulaInl" alt="$a&lt;b$" src="form_71.png"/>, the number of distinct roots of <img class="formulaInl" alt="$f(x)$" src="form_16.png"/> in <img class="formulaInl" alt="$(a,b]$" src="form_72.png"/> is given by <img class="formulaInl" alt="$\sigma(a)-\sigma(b)$" src="form_73.png"/>.</p>
<p>This gives a method to calculate the exact number of real and distinct roots in a region, which can then be used in a bisection routine to bound individual distinct roots. The Sturm sequence can also be easily evaluated at infinite bounds <img class="formulaInl" alt="$(-\infty,+\infty)$" src="form_74.png"/> to determine the total number of real roots.</p>
<p>Although this method allows the construction of an arbitrary-order <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> root finder through bisection, inexact methods for computing the number of roots in a region (such as <a class="el" href="classsym_1_1Polynomial.html#aeee847c21ce675b9feae0b56d1472a49">descartes_rule_of_signs</a>, used in <a class="el" href="classsym_1_1Polynomial.html#aca149415a6be49299ba0ad27fdffff68">VAS_real_root_bounds</a>) are preferred as they are more computationally efficient. </p>

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l01214">1214</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3a6f50a9ba9a5a4c0d2aadb0ed5720f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Coeff_t , size_t Order, class Var1 , class Var2 , class... VarArgs, typename  = typename enable_if_var_in&lt;Var2, Var1&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, <a class="el" href="structsym_1_1Var.html">Var</a>&lt; VarArgs... &gt; &gt; sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, Var1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsym_1_1Relation.html">Relation</a>&lt; Var2, <a class="el" href="structsym_1_1Var.html">Var</a>&lt; VarArgs... &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_container</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l00181">181</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a998b515498150d338099ddbb620eb548"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Order, class Coeff_t , class PolyVar , class SubVar , typename  = typename enable_if_var_in&lt;PolyVar, SubVar&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Coeff_t sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsym_1_1Relation.html">Relation</a>&lt; SubVar, <a class="el" href="namespacesym.html#a906fb1169f4d948d53f4e868a14fe783">Null</a> &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l00188">188</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a48af67fa52a16f26c3242ceb5ed170ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Coeff_t , size_t Order, class PolyVar , class SubVar , class Coeff_t2 , typename  = typename std::enable_if&lt;!std::is_arithmetic&lt;Coeff_t2&gt;::value                                              || (std::is_base_of&lt;Eigen::EigenBase&lt;Coeff_t2&gt;, Coeff_t2&gt;::value &amp;&amp; std::is_arithmetic&lt;Coeff_t2&gt;::value)                                              || (std::is_base_of&lt;Eigen::EigenBase&lt;Coeff_t&gt;, Coeff_t&gt;::value &amp;&amp; std::is_arithmetic&lt;Coeff_t2&gt;::value)                                              &gt;::type, typename  = typename enable_if_var_in&lt;PolyVar, SubVar&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsym_1_1Relation.html">Relation</a>&lt; SubVar, Coeff_t2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_container</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="config_8hpp.html#aba3f0e2e567a0a1cedd890915cd5b7c5">STATOR_AUTORETURN</a>(<a class="el" href="structsym_1_1detail_1_1PolySubWorker.html">detail::PolySubWorker</a>&lt;Order&gt;::eval(f, x_container._val))

  
  template&lt;size_t D, size_t Order, class Coeff_t, class PolyVar, class Coeff_t2&gt;
  std::array&lt;Coeff_t, D+1&gt; eval_derivatives(const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt;Order, Coeff_t, PolyVar&gt;&amp; f, const Coeff_t2&amp; x)
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>As the intermediate and final return types of a symbolic evaluation are unknown, this must be handled using template metaprogramming to unfold the multiplication. This is provided by the <a class="el" href="structsym_1_1detail_1_1PolySubWorker.html" title="Worker class for symbolically evaluating a substitution on a Polynomial. ">detail::PolySubWorker</a> classes.</p>
<p>The method used to evaluate the polynomial is known as Horner's method. </p>

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l00285">285</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca149415a6be49299ba0ad27fdffff68"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstator_1_1orphan_1_1StackVector.html">StackVector</a>&lt; std::pair&lt; Coeff_t, Coeff_t &gt;, Order &gt; VAS_real_root_bounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function uses the VAS algorithm to bound the roots and assumes the polynomial has non-zero constant and leading order coefficients. This function enforces these conditions before passing it to <a class="el" href="classsym_1_1Polynomial.html#ae0f0d655af888ae542aad0aa089f6f56">VAS_real_root_bounds_worker</a>. </p>

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l01637">1637</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae0f0d655af888ae542aad0aa089f6f56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstator_1_1orphan_1_1StackVector.html">StackVector</a>&lt; std::pair&lt; Coeff_t, Coeff_t &gt;, Order &gt; VAS_real_root_bounds_worker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsym_1_1MobiusTransform.html">MobiusTransform</a>&lt; Coeff_t &gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function uses the VAS algorithm to bound the roots and assumes the polynomial has non-zero constant and leading order coefficients.</p>
<p>The parameter M is an array of Mobius transformation coefficients {a,b,c,d}. By default it is a direct mapping to the original <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a>. </p>

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l01539">1539</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aee5683891b03388fb5131a93fb70bdf8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstator_1_1orphan_1_1StackVector.html">StackVector</a>&lt; std::pair&lt; Coeff_t, Coeff_t &gt;, Order &gt; VCA_real_root_bounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function uses the VCA algorithm to bound the roots and assumes the polynomial has non-zero constant and leading order coefficients. This function enforces these requirements and then simply scales the <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> so that all roots lie in the range (0,1) before passing it to <a class="el" href="classsym_1_1Polynomial.html#a427e79f2856cec57c54f5dd02563cb4e">VCA_real_root_bounds_worker</a>. </p>

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l01433">1433</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a427e79f2856cec57c54f5dd02563cb4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Order, class Coeff_t , class PolyVar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstator_1_1orphan_1_1StackVector.html">StackVector</a>&lt; std::pair&lt; Coeff_t, Coeff_t &gt;, Order &gt; VCA_real_root_bounds_worker </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsym_1_1Polynomial.html">Polynomial</a>&lt; Order, Coeff_t, PolyVar &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function uses the VCA algorithm to bound the roots. It assumes that the polynomial has a non-zero constant term and leading order coefficient term. </p>

<p>Definition at line <a class="el" href="polynomial_8hpp_source.html#l01370">1370</a> of file <a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/mjki2mb2/stator/stator/symbolic/<a class="el" href="polynomial_8hpp_source.html">polynomial.hpp</a></li>
<li>/home/mjki2mb2/stator/stator/symbolic/<a class="el" href="simplify_8hpp_source.html">simplify.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Apr 15 2017 19:48:02 for stator by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
