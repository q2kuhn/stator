<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>stator: sym::detail::ExprTokenizer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">stator
   </div>
   <div id="projectbrief">A math, geometry, and utility library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesym.html">sym</a></li><li class="navelem"><a class="el" href="namespacesym_1_1detail.html">detail</a></li><li class="navelem"><a class="el" href="classsym_1_1detail_1_1ExprTokenizer.html">ExprTokenizer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classsym_1_1detail_1_1ExprTokenizer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sym::detail::ExprTokenizer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation of expression tokenization and parsing into <a class="el" href="structsym_1_1Expr.html" title="The generic holder/smart pointer for a runtime Abstract Syntax Tree (AST) (expression). ">Expr</a> types.  
 <a href="classsym_1_1detail_1_1ExprTokenizer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="parser_8hpp_source.html">parser.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsym_1_1detail_1_1ExprTokenizer_1_1BinaryOpToken.html">BinaryOpToken</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsym_1_1detail_1_1ExprTokenizer_1_1HaltToken.html">HaltToken</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsym_1_1detail_1_1ExprTokenizer_1_1LeftOperatorBase.html">LeftOperatorBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsym_1_1detail_1_1ExprTokenizer_1_1ParenthesisToken.html">ParenthesisToken</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsym_1_1detail_1_1ExprTokenizer_1_1RightOperatorBase.html">RightOperatorBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsym_1_1detail_1_1ExprTokenizer_1_1SkipToken.html">SkipToken</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsym_1_1detail_1_1ExprTokenizer_1_1UnaryNegative.html">UnaryNegative</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsym_1_1detail_1_1ExprTokenizer_1_1UnaryOpToken.html">UnaryOpToken</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a41a79e08de025b116469bc8608fbff85"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsym_1_1detail_1_1ExprTokenizer.html#a41a79e08de025b116469bc8608fbff85">ExprTokenizer</a> (const std::string &amp;str)</td></tr>
<tr class="separator:a41a79e08de025b116469bc8608fbff85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368623629b1b368ae87305a906efd5ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsym_1_1detail_1_1ExprTokenizer.html#a368623629b1b368ae87305a906efd5ed">consume</a> ()</td></tr>
<tr class="separator:a368623629b1b368ae87305a906efd5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d32e2bb77d442d8382b0ed254869d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsym_1_1detail_1_1ExprTokenizer.html#af1d32e2bb77d442d8382b0ed254869d8">consumeFloat</a> ()</td></tr>
<tr class="separator:af1d32e2bb77d442d8382b0ed254869d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b940dcd6b08be677fe71af59a95b43"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsym_1_1detail_1_1ExprTokenizer.html#a60b940dcd6b08be677fe71af59a95b43">empty</a> () const</td></tr>
<tr class="separator:a60b940dcd6b08be677fe71af59a95b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83caba39bcce631f4c0a76e1576f768f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsym_1_1detail_1_1ExprTokenizer.html#a83caba39bcce631f4c0a76e1576f768f">expect</a> (std::string token)</td></tr>
<tr class="separator:a83caba39bcce631f4c0a76e1576f768f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8038f0f2192a47354c3c4ab07b4f8899"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsym_1_1detail_1_1ExprTokenizer.html#a8038f0f2192a47354c3c4ab07b4f8899">next</a> ()</td></tr>
<tr class="separator:a8038f0f2192a47354c3c4ab07b4f8899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec0494b97e70d574aee45e247b1fa53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsym_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsym_1_1detail_1_1ExprTokenizer.html#a1ec0494b97e70d574aee45e247b1fa53">parseExpression</a> (int minLBP=0)</td></tr>
<tr class="memdesc:a1ec0494b97e70d574aee45e247b1fa53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main parsing entry function.  <a href="#a1ec0494b97e70d574aee45e247b1fa53">More...</a><br /></td></tr>
<tr class="separator:a1ec0494b97e70d574aee45e247b1fa53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11002fc30bdde43d2880b719af5a5bc7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsym_1_1detail_1_1ExprTokenizer.html#a11002fc30bdde43d2880b719af5a5bc7">parserLoc</a> ()</td></tr>
<tr class="separator:a11002fc30bdde43d2880b719af5a5bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac523ade685ba1842156ee367004ac71b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsym_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsym_1_1detail_1_1ExprTokenizer.html#ac523ade685ba1842156ee367004ac71b">parseToken</a> ()</td></tr>
<tr class="memdesc:ac523ade685ba1842156ee367004ac71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a single token (unary/prefix op, variable, or number), where precedence issues do not arise.  <a href="#ac523ade685ba1842156ee367004ac71b">More...</a><br /></td></tr>
<tr class="separator:ac523ade685ba1842156ee367004ac71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:acfb5d6f549abad9579f90f83d109ac4c"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, shared_ptr&lt; <a class="el" href="structsym_1_1detail_1_1ExprTokenizer_1_1LeftOperatorBase.html">LeftOperatorBase</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsym_1_1detail_1_1ExprTokenizer.html#acfb5d6f549abad9579f90f83d109ac4c">_left_operators</a></td></tr>
<tr class="separator:acfb5d6f549abad9579f90f83d109ac4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0d20a11902b236d549636e94b8bc24"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, shared_ptr&lt; <a class="el" href="structsym_1_1detail_1_1ExprTokenizer_1_1RightOperatorBase.html">RightOperatorBase</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsym_1_1detail_1_1ExprTokenizer.html#a4b0d20a11902b236d549636e94b8bc24">_right_operators</a></td></tr>
<tr class="separator:a4b0d20a11902b236d549636e94b8bc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The structure of the code:</p><ul>
<li>The splitting of the string into tokens occurs in the <a class="el" href="classsym_1_1detail_1_1ExprTokenizer.html#a368623629b1b368ae87305a906efd5ed">ExprTokenizer::consume</a> member function.</li>
<li>Conversion of tokens into unary/prefix operators occurs in <a class="el" href="classsym_1_1detail_1_1ExprTokenizer.html#ac523ade685ba1842156ee367004ac71b">ExprTokenizer::parseToken</a>.</li>
</ul>
<p>Finally, the binary operator precedence and parsing takes place in .</p>
<p>The implementation is largely based around the pseudocode implementations of Theodore Norvell from <a href="http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm">here</a> and in particular <a href="http://www.engr.mun.ca/~theo/Misc/pratt_parsing.htm">here</a>.</p>
<p>The algorithm is implemented over four key functions:</p><ol type="1">
<li>Initialisation of all operator definitions takes place in the constructor <a class="el" href="classsym_1_1detail_1_1ExprTokenizer.html#a41a79e08de025b116469bc8608fbff85">ExprTokenizer::ExprTokenizer</a>.</li>
<li>Expression strings are first broken down into tokens. Tokens are substrings such as "2", "*", "sin", or "(". <a class="el" href="classsym_1_1detail_1_1ExprTokenizer.html#a8038f0f2192a47354c3c4ab07b4f8899">ExprTokenizer::next</a> yields the current token, and the system is moved onto the next using <a class="el" href="classsym_1_1detail_1_1ExprTokenizer.html#a368623629b1b368ae87305a906efd5ed">ExprTokenizer::consume</a> (where the actual tokenization takes place).</li>
</ol>
<p>Parsing of "leaves" of the Abstract Syntax Tree (AST), such as variables, numbers, including functions/prefix-operators are handled via <a class="el" href="classsym_1_1detail_1_1ExprTokenizer.html#ac523ade685ba1842156ee367004ac71b" title="Parses a single token (unary/prefix op, variable, or number), where precedence issues do not arise...">ExprTokenizer::parseToken</a>. Functions and prefix-operators may contain sub-trees and these are parsed recursively.</p><ol type="1">
<li><p class="startli">Full expression strings/trees are parsed via <a class="el" href="classsym_1_1detail_1_1ExprTokenizer.html#a1ec0494b97e70d574aee45e247b1fa53">ExprTokenizer::parseExpression</a>. Its main purpose is to resolve binary operator precedence.</p>
<p class="startli">The hardest part for me to understand from the work of Theodore Norvell was how the <a class="el" href="classsym_1_1detail_1_1ExprTokenizer.html#a1ec0494b97e70d574aee45e247b1fa53" title="Main parsing entry function. ">ExprTokenizer::parseExpression</a> function created the AST via recursion and "precedence climbing". My notes on this are available in the documentation for <a class="el" href="classsym_1_1detail_1_1ExprTokenizer.html#a1ec0494b97e70d574aee45e247b1fa53" title="Main parsing entry function. ">ExprTokenizer::parseExpression</a>. </p>
</li>
</ol>

<p class="definition">Definition at line <a class="el" href="parser_8hpp_source.html#l00056">56</a> of file <a class="el" href="parser_8hpp_source.html">parser.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a41a79e08de025b116469bc8608fbff85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a79e08de025b116469bc8608fbff85">&#9670;&nbsp;</a></span>ExprTokenizer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sym::detail::ExprTokenizer::ExprTokenizer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parser_8hpp_source.html#l00058">58</a> of file <a class="el" href="parser_8hpp_source.html">parser.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a368623629b1b368ae87305a906efd5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a368623629b1b368ae87305a906efd5ed">&#9670;&nbsp;</a></span>consume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sym::detail::ExprTokenizer::consume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parser_8hpp_source.html#l00129">129</a> of file <a class="el" href="parser_8hpp_source.html">parser.hpp</a>.</p>

</div>
</div>
<a id="af1d32e2bb77d442d8382b0ed254869d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d32e2bb77d442d8382b0ed254869d8">&#9670;&nbsp;</a></span>consumeFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sym::detail::ExprTokenizer::consumeFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parser_8hpp_source.html#l00167">167</a> of file <a class="el" href="parser_8hpp_source.html">parser.hpp</a>.</p>

</div>
</div>
<a id="a60b940dcd6b08be677fe71af59a95b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b940dcd6b08be677fe71af59a95b43">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sym::detail::ExprTokenizer::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parser_8hpp_source.html#l00125">125</a> of file <a class="el" href="parser_8hpp_source.html">parser.hpp</a>.</p>

</div>
</div>
<a id="a83caba39bcce631f4c0a76e1576f768f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83caba39bcce631f4c0a76e1576f768f">&#9670;&nbsp;</a></span>expect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sym::detail::ExprTokenizer::expect </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parser_8hpp_source.html#l00119">119</a> of file <a class="el" href="parser_8hpp_source.html">parser.hpp</a>.</p>

</div>
</div>
<a id="a8038f0f2192a47354c3c4ab07b4f8899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8038f0f2192a47354c3c4ab07b4f8899">&#9670;&nbsp;</a></span>next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string sym::detail::ExprTokenizer::next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parser_8hpp_source.html#l00115">115</a> of file <a class="el" href="parser_8hpp_source.html">parser.hpp</a>.</p>

</div>
</div>
<a id="a1ec0494b97e70d574aee45e247b1fa53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec0494b97e70d574aee45e247b1fa53">&#9670;&nbsp;</a></span>parseExpression()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsym_1_1Expr.html">Expr</a> sym::detail::ExprTokenizer::parseExpression </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minLBP</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<ul>
<li>minLBP The minimum binding power of an operator that this call can collect. A value of zero collects all operators.</li>
</ul>
<p>This function handles all cases where operator precedence arises.</p>
<p>Expressions are streams of tokens. As the tokens are read left-to-right, we always begin with the leftmost leaf of the AST. The first call to parseExpression must then climb UP the AST to its top. The variable maxLBP ensures that each call to parseExpression only climbs up by ensuring that operators with higher precendence than p are handled by a recursion, possibly to become left leafs of a lower-precedence operator higher up the AST (low precedence operators always end up high up the AST). The variable minLBP is used to make sure that each recursive call to parseExpression does not climb above its parent parseExpression call.</p>
<p>There are three types of precedence used.</p>
<p>Left Binding Precedence (LBP) and Right Binding Precedence (RBP) are used to determine which operator binds to an argument between two operators. For example, in the expression 2*3+4, the multiply binds to the 3 as its RBP is higher than the addition's LBP. If the LBP and RBP are equal, the right operator "wins". Thus operators who are left-associative must have their RBP &gt; LBP, and right-associative operators must have RBP &lt;= LBP.</p>
<p>The last argument is the Next Binding Precedence (NBP). As parseExpression climbs up the AST, the NBP of each operator is used to determine the maximum LBP which will cause the parseExpression to replace its current root with a higher level. Generally, an operator must have NBP&lt;=LBP. For left-associative operators we have NBP=LBP, and for right associative we have NBP&lt;LBP, as we are moving from left to right along the tree and thus only left-associative operators allow us to ascend (which we do at each repeated left-associative operator). </p>

<p class="definition">Definition at line <a class="el" href="parser_8hpp_source.html#l00388">388</a> of file <a class="el" href="parser_8hpp_source.html">parser.hpp</a>.</p>

</div>
</div>
<a id="a11002fc30bdde43d2880b719af5a5bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11002fc30bdde43d2880b719af5a5bc7">&#9670;&nbsp;</a></span>parserLoc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string sym::detail::ExprTokenizer::parserLoc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parser_8hpp_source.html#l00215">215</a> of file <a class="el" href="parser_8hpp_source.html">parser.hpp</a>.</p>

</div>
</div>
<a id="ac523ade685ba1842156ee367004ac71b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac523ade685ba1842156ee367004ac71b">&#9670;&nbsp;</a></span>parseToken()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsym_1_1Expr.html">Expr</a> sym::detail::ExprTokenizer::parseToken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parser_8hpp_source.html#l00315">315</a> of file <a class="el" href="parser_8hpp_source.html">parser.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="acfb5d6f549abad9579f90f83d109ac4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb5d6f549abad9579f90f83d109ac4c">&#9670;&nbsp;</a></span>_left_operators</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, shared_ptr&lt;<a class="el" href="structsym_1_1detail_1_1ExprTokenizer_1_1LeftOperatorBase.html">LeftOperatorBase</a>&gt; &gt; sym::detail::ExprTokenizer::_left_operators</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parser_8hpp_source.html#l00309">309</a> of file <a class="el" href="parser_8hpp_source.html">parser.hpp</a>.</p>

</div>
</div>
<a id="a4b0d20a11902b236d549636e94b8bc24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b0d20a11902b236d549636e94b8bc24">&#9670;&nbsp;</a></span>_right_operators</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, shared_ptr&lt;<a class="el" href="structsym_1_1detail_1_1ExprTokenizer_1_1RightOperatorBase.html">RightOperatorBase</a>&gt; &gt; sym::detail::ExprTokenizer::_right_operators</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parser_8hpp_source.html#l00310">310</a> of file <a class="el" href="parser_8hpp_source.html">parser.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/mjki2mb2/stator/stator/symbolic/<a class="el" href="parser_8hpp_source.html">parser.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 9 2017 08:13:04 for stator by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
