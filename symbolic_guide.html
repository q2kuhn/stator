<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>stator: Guide to stator::sym</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">stator
   </div>
   <div id="projectbrief">A math, geometry, and utility library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Guide to stator::sym </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is a short introduction to the compile-time symbolic algebra library (see <a class="el" href="symbolic__example_8cpp.html" title="An example of how to use the stator::symbolic library. ">symbolic_example.cpp</a>).</p>
<p>To use stator, first include the stator::sym library header file and bring the sym namespace into scope for convenience:</p>
 <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="symbolic_8hpp.html">stator/symbolic/symbolic.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="unit__test_8hpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacesym.html">sym</a>;</div></div><!-- fragment --></p>
<h1><a class="anchor" id="sym_guide_var"></a>
Variables</h1>
<p>Variables are a critical component of a CAS system. Each variable is a placeholder for a future expression and thus needs a unique index to identify it. These are identified in stator either using a single character or an index:</p>
<p><div class="fragment"><div class="line">  <span class="comment">//The default variable is the letter x</span></div><div class="line">  Var&lt;&gt; x;</div><div class="line">  </div><div class="line">  <span class="comment">//But you can specify your own variables by letter:</span></div><div class="line">  Var&lt;vidx&lt;&#39;y&#39;&gt; &gt; y;</div><div class="line">  </div><div class="line">  <span class="comment">//Or by index:</span></div><div class="line">  Var&lt;vidx&lt;42&gt;&gt; v42;</div></div><!-- fragment --></p>
<p>Expressions using variables (and all derived classes of <a class="el" href="structsym_1_1SymbolicOperator.html" title="A type trait to denote symbolic terms (i.e., one that is not yet immediately evaluable to a &quot;normal&quot; ...">sym::SymbolicOperator</a>) are not evaluated immediately, but result in symbolic expressions:</p>
<p><div class="fragment"><div class="line">  <span class="comment">//We have to catch symbolic expressions using &quot;auto&quot; as their type is very complex</span></div><div class="line">  <span class="keyword">auto</span> f1 = x * x + <a class="code" href="namespacesym.html#a0c79e749c3c77b0485b42597830cbcdf">sin</a>(y);</div><div class="line">  </div><div class="line">  std::cout &lt;&lt; f1 &lt;&lt; std::endl;</div><div class="line">  <span class="comment">//Output: ((x × x) + sin(y))</span></div></div><!-- fragment --></p>
<p>Variables can be substituted for other variables, for example, we can replace <img class="formulaInl" alt="$x$" src="form_0.png"/> with <img class="formulaInl" alt="$y+2$" src="form_1.png"/>:</p>
<p><div class="fragment"><div class="line">  <span class="keyword">auto</span> f1_xsub = <a class="code" href="namespacesym.html#add9acccf6849c06acc39ec0412e42851">sub</a>(f1, x = y + 2);</div><div class="line">  </div><div class="line">  std::cout &lt;&lt; f1_xsub &lt;&lt; std::endl;</div><div class="line">  <span class="comment">//Output: (((y + 2) × (y + 2)) + sin(y))</span></div></div><!-- fragment --></p>
<p>To evaluate an expression, all variables (and other symbolic types) must be substituted for non-symbolic values. A final substitution for <img class="formulaInl" alt="$y=\pi$" src="form_2.png"/> in the previous expression causes a complete evaluation to a double type:</p>
<p><div class="fragment"><div class="line">  std::cout &lt;&lt; <a class="code" href="namespacesym.html#add9acccf6849c06acc39ec0412e42851">sub</a>(f1_xsub, y = 3.14159265359) &lt;&lt; std::endl;</div><div class="line">  <span class="comment">//Output: 26.436...</span></div></div><!-- fragment --></p>
<p>All of this is evaluated at compile time into the basic floating point operations, which also may be optimised away, thus complex mathematics may be written in a natural way without worrying about computational cost.</p>
<h1><a class="anchor" id="sym_guide_const"></a>
Rational constants</h1>
<p>Stator can work with standard arithmetic terms (integers, floats); however, they only have limited compile-time symbolic support. For example, the following expression cannot be simplified by stator:</p>
<p><div class="fragment"><div class="line">  <span class="keyword">auto</span> f2 = (3-3) * x;</div><div class="line">  std::cout &lt;&lt; f2 &lt;&lt; std::endl;</div><div class="line">  <span class="comment">//Output: (0 × x)</span></div></div><!-- fragment --></p>
<p>The difficulty here is that the compiler cannot deduce the value of an integer or float from its type (which is all the compiler has access to). C++11 gave us std::ratio, which allows rational constants to be encoded as a ratio of two integer values. In stator, this has been extended to give the rational constant type, <a class="el" href="structsym_1_1C.html">sym::C</a>. This allows the compiler to perform rational arithmetic at compile time:</p>
<p><div class="fragment"><div class="line">  C&lt;1, 2&gt; half;</div><div class="line">  C&lt;2&gt; two;</div><div class="line">  </div><div class="line">  <span class="comment">//Compile-time rational arithmetic!</span></div><div class="line">  <span class="keyword">auto</span> three = half + half + two;</div><div class="line"></div><div class="line">  <span class="comment">//The variable three is of type &quot;C&lt;3&gt;&quot;, thus it must be computed at compile time.</span></div><div class="line">  assert((std::is_same&lt;decltype(three), C&lt;3&gt; &gt;::value)); <span class="comment">//does not fail</span></div><div class="line">  </div><div class="line">  std::cout &lt;&lt; three &lt;&lt; std::endl;</div><div class="line">  <span class="comment">//Output: C&lt;3&gt;()</span></div></div><!-- fragment --></p>
<p>When the rational constant type <a class="el" href="structsym_1_1C.html" title="A class representing a compile-time rational constant (i.e., std::ratio). ">sym::C</a> is used, stator can cancel zero terms. For example, any term multiplied by <a class="el" href="namespacesym.html#a906fb1169f4d948d53f4e868a14fe783">C&lt;0&gt;</a> (which has a convenient typedef of <a class="el" href="namespacesym.html#a906fb1169f4d948d53f4e868a14fe783">sym::Null</a>) is cancelled to zero at compile time:</p>
<p><div class="fragment"><div class="line">  <span class="keyword">auto</span> f3 = (<a class="code" href="namespacesym.html#ae0f95c65d7f365bada07d7a8e18fce96">C&lt;1&gt;</a>() - <a class="code" href="namespacesym.html#ae0f95c65d7f365bada07d7a8e18fce96">C&lt;1&gt;</a>()) * <a class="code" href="namespacesym.html#a0c79e749c3c77b0485b42597830cbcdf">sin</a>(x);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; f3 &lt;&lt; std::endl;</div><div class="line">  <span class="comment">//Output: C&lt;0&gt;()</span></div></div><!-- fragment --></p>
<p>Equally, any term multiplied by <a class="el" href="namespacesym.html#ad051764c07e9b8c84b6a313f99026631">C&lt;1&gt;</a> (which has a convenient typedef of <a class="el" href="namespacesym.html#ad051764c07e9b8c84b6a313f99026631">sym::Unity</a>), is left unchanged:</p>
<p><div class="fragment"><div class="line">  <span class="keyword">auto</span> f4 = <a class="code" href="namespacesym.html#ae0f95c65d7f365bada07d7a8e18fce96">C&lt;1&gt;</a>() * <a class="code" href="namespacesym.html#a0c79e749c3c77b0485b42597830cbcdf">sin</a>(x);</div><div class="line">  std::cout &lt;&lt; f4 &lt;&lt; std::endl;</div><div class="line">  <span class="comment">//Output: sin(x)</span></div></div><!-- fragment --></p>
<p>To enable this powerful simplification, <a class="el" href="structsym_1_1C.html">sym::C</a> values should be used wherever possible.</p>
<h1><a class="anchor" id="sym_guide_calculus"></a>
Calculus, simplification, and other transformations</h1>
<p>As mathematical expressions are encoded as types, the compiler can apply transformations to them. For example, the derivative can be evaluated at compile-time:</p>
<p><div class="fragment"><div class="line">  <span class="keyword">auto</span> f5 = <a class="code" href="namespacesym.html#a28faa10fb59352219a6f60552a310d76">cos</a>(2 * x);</div><div class="line">  <span class="keyword">auto</span> df5_dx = <a class="code" href="namespacesym.html#a3a233c6a712dc329484065702b97162e">derivative</a>(f5, x);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; df5_dx &lt;&lt; std::endl;</div><div class="line">  <span class="comment">//Output: (-2 × sin((2 × x)))</span></div></div><!-- fragment --></p>
<p>More complex operations are available, such as Taylor series:</p>
<p><div class="fragment"><div class="line">  <span class="comment">//A taylor series of sin(2x) around zero</span></div><div class="line">  std::cout &lt;&lt; taylor_series&lt;3&gt;(<a class="code" href="namespacesym.html#a0c79e749c3c77b0485b42597830cbcdf">sin</a>(C&lt;2&gt;() * x), C&lt;0&gt;(), x) &lt;&lt; std::endl;</div><div class="line">  <span class="comment">//Output: (x × (C&lt;2&gt;() + ((x ^ C&lt;2&gt;()) × C&lt;-4,3&gt;())))</span></div></div><!-- fragment --></p>
<p>The output can rapidly become ugly. Fortunately, basic simplification is available via <a class="el" href="namespacesym.html#a278c5774e9bfac198c2062d59c16f47d">sym::simplify</a>. For example:</p>
<p><div class="fragment"><div class="line">  std::cout &lt;&lt; x * x * x * x * x &lt;&lt; std::endl;</div><div class="line">  <span class="comment">//Output: ((((x × x) × x) × x) × x)</span></div><div class="line"></div><div class="line">  std::cout &lt;&lt; <a class="code" href="namespacesym.html#a278c5774e9bfac198c2062d59c16f47d">simplify</a>(x * x * x * x * x) &lt;&lt; std::endl;</div><div class="line">  <span class="comment">//Output: (x ^ C&lt;5&gt;())         (which is equivalent to &quot;pow(x, C&lt;5&gt;())&quot;)</span></div></div><!-- fragment --></p>
<p>Please note, simplify only exists if there is a simplification to be made and will fail at compile time if there is not. You can also use <a class="el" href="namespacesym.html#a3f9a1a1a540d6eafc3a09e9454368d42" title="A method to apply simplification only if it is available. ">sym::try_simplify</a> if you do not want missing simplification to be an error.</p>
<p>The Taylor series expansion above actually has no simplification. However, it can be converted into a <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">Polynomial</a> type, which gives a simpler representation and allows further functional analysis.</p>
<h1><a class="anchor" id="sym_guide_poly"></a>
Polynomial types</h1>
<p>The <a class="el" href="namespacesym.html#a69d878cb265d79b4dd2d2b145108e79e" title="A variant of simplify that expands into Polynomial types aggressively. ">sym::expand</a> function attempts to collect the coefficients of a polynomial and create a <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">sym::Polynomial</a> type:</p>
<p><div class="fragment"><div class="line">  </div><div class="line">  <span class="keyword">auto</span> f6 = taylor_series&lt;3&gt;(<a class="code" href="namespacesym.html#a0c79e749c3c77b0485b42597830cbcdf">sin</a>(C&lt;2&gt;() * x), C&lt;0&gt;(), x);</div><div class="line">  std::cout &lt;&lt; f6 &lt;&lt; std::endl;</div><div class="line">  <span class="comment">//Output: (x × (C&lt;2&gt;() + ((x ^ C&lt;2&gt;()) × C&lt;-4,3&gt;())))</span></div><div class="line"></div><div class="line">  <span class="keyword">auto</span> f6_poly = <a class="code" href="namespacesym.html#a69d878cb265d79b4dd2d2b145108e79e">expand</a>(f6);</div><div class="line">  std::cout &lt;&lt; f6_poly &lt;&lt; std::endl;</div><div class="line">  <span class="comment">//Output: P(-1.33333 × x³ + 2 × x)</span></div></div><!-- fragment --></p>
<p>The output here is a <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">sym::Polynomial</a> type (as indicated by the "P()" wrapper). The <a class="el" href="classsym_1_1Polynomial.html" title="Array representation of Polynomial. ">sym::Polynomial</a> is simply an array of coefficients, from lowest to highest order:</p>
<p><div class="fragment"><div class="line"></div><div class="line">  std::cout &lt;&lt; f6_poly[0] &lt;&lt; std::endl;</div><div class="line">  <span class="comment">//Output: 0</span></div><div class="line">  std::cout &lt;&lt; f6_poly[3] &lt;&lt; std::endl;</div><div class="line">  <span class="comment">//Output: -1.33333</span></div></div><!-- fragment --></p>
<p>Most importantly, the polynomial type allows further functional analysis, such as determining the roots of the polynomial:</p>
<p><div class="fragment"><div class="line">  <span class="comment">//Then we can analyse its real roots!</span></div><div class="line">  <span class="keyword">auto</span> f6_roots = <a class="code" href="namespacesym.html#a50d2d7aed658c33bd5e32a913ef886a8">solve_real_roots</a>(f6_poly);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; f6_roots &lt;&lt; std::endl;</div><div class="line">  <span class="comment">//Output: StackVector{ -1.22474 0 1.22474 }</span></div><div class="line"></div><div class="line">  <span class="comment">//Extracting the number of roots</span></div><div class="line">  std::cout &lt;&lt; f6_roots.size() &lt;&lt; std::endl;</div><div class="line">  <span class="comment">//Output: 3</span></div><div class="line">  </div><div class="line">  <span class="comment">//Extracting a value of a root</span></div><div class="line">  std::cout &lt;&lt; f6_roots[2] &lt;&lt; std::endl;</div><div class="line">  <span class="comment">//Output: 1.22474</span></div></div><!-- fragment --></p>
<p>Here there are three real roots, and they are returned in a <a class="el" href="classstator_1_1orphan_1_1StackVector.html">StackVector</a>, which is like a std::vector with a fixed maximum size allowing it to be allocated on the stack.</p>
<p>The library is capable of solving for all of the real roots of arbitrary polynomials but relies on numerical iteration schemes for polynomials of any order greater than three.</p>
<h1><a class="anchor" id="vec_sym_guide"></a>
Vector expressions</h1>
<p>The symbolic library also supports Eigen vector/matrix expressions.</p>
<p><div class="fragment"><div class="line">  Eigen::Matrix&lt;double, 1, 3&gt; r{1.0, 2.0, 3.0};</div><div class="line">  Eigen::Matrix&lt;double, 1, 3&gt; v{1.0, 0.5, 0.1};</div><div class="line">  <span class="keyword">auto</span> fvec = r + x * v;</div><div class="line">  std::cout &lt;&lt; <a class="code" href="namespacesym.html#add9acccf6849c06acc39ec0412e42851">sub</a>(fvec, x = 12) &lt;&lt; std::endl;</div><div class="line">  <span class="comment">//Output:  13   8 4.2</span></div></div><!-- fragment --></p>
<p>You have to be careful though. Eigen preserves the row/column nature of the vectors so operations like multiplication may cause compile errors </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Apr 15 2017 19:47:58 for stator by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
